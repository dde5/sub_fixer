<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å­—å¹•å…¨èƒ½å·¥å…· Pro</title>
    <!-- YouTube IFrame Player API -->
    <script src="https://www.youtube.com/iframe_api"></script>
    <style>
        /* Modern UI Redesign by a 20-year UI Master */
        :root {
            --font-sans: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
            
            /* Light Theme */
            --bg: #f8fafc;
            --bg-alt: #f1f5f9;
            --bg-card: #ffffff;
            --bg-input: #ffffff;
            --bg-hover: #f1f5f9;
            --bg-active: #e2e8f0;

            --text-primary: #0f172a;
            --text-secondary: #64748b;
            --text-accent: #2563eb;
            --text-on-accent: #ffffff;

            --border: #e2e8f0;
            --border-focus: #3b82f6;

            --shadow: 0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1);
            --shadow-md: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
            
            --radius-sm: 0.25rem;
            --radius-md: 0.5rem;
            --radius-lg: 0.75rem;

            --green-bg: #dcfce7;
            --green-text: #166534;
            --red-bg: #fee2e2;
            --red-text: #991b1b;
            --blue-bg: #dbeafe;
            --blue-text: #1e40af;
            --yellow-bg: #fef9c3;
            --yellow-text: #854d0e;
        }

        [data-theme="dark"] {
            --bg: #020617;
            --bg-alt: #0f172a;
            --bg-card: #1e293b;
            --bg-input: #334155;
            --bg-hover: #334155;
            --bg-active: #475569;
            
            --text-primary: #f8fafc;
            --text-secondary: #94a3b8;
            --text-accent: #60a5fa;
            --text-on-accent: #0f172a;
            
            --border: #334155;
            --border-focus: #60a5fa;

            --green-bg: #14532d;
            --green-text: #bef264;
            --red-bg: #7f1d1d;
            --red-text: #fca5a5;
            --blue-bg: #1e3a8a;
            --blue-text: #bfdbfe;
            --yellow-bg: #713f12;
            --yellow-text: #fde047;
        }

        *, *::before, *::after { box-sizing: border-box; }
        html { scroll-behavior: smooth; }
        body {
            font-family: var(--font-sans);
            margin: 0;
            background-color: var(--bg);
            color: var(--text-primary);
            transition: background-color 0.3s ease, color 0.3s ease, padding-top 0.3s ease;
        }

        /* --- Main Layout & App Header --- */
        .app-container {
            width: 95%;
            max-width: 1400px;
            margin: 0 auto;
            padding: 1.5rem 1rem;
        }
        .app-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
        }
        .app-header h1 {
            font-size: 1.875rem;
            margin: 0;
            color: var(--text-primary);
        }
        .header-actions {
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }
        .icon-btn {
            background-color: transparent;
            border: 1px solid var(--border);
            color: var(--text-secondary);
            width: 40px;
            height: 40px;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.25rem;
            transition: all 0.2s ease;
        }
        .icon-btn:hover {
            background-color: var(--bg-hover);
            color: var(--text-accent);
            border-color: var(--text-accent);
        }
        #theme-toggle .moon-icon { display: none; }
        [data-theme="dark"] #theme-toggle .sun-icon { display: none; }
        [data-theme="dark"] #theme-toggle .moon-icon { display: inline; }
        .main-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1.5rem;
            align-items: start;
        }
        .grid-span-2 { grid-column: 1 / -1; }

        /* --- Card Component --- */
        .card {
            background-color: var(--bg-card);
            border-radius: var(--radius-lg);
            border: 1px solid var(--border);
            box-shadow: var(--shadow);
            overflow: hidden;
            display: flex;
            flex-direction: column;
            transition: all 0.3s ease;
        }
        .card-header {
            padding: 0.75rem 1.25rem;
            border-bottom: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .card-header h2 {
            font-size: 1.125rem;
            margin: 0;
            color: var(--text-primary);
        }
        .card-header-actions { display: flex; gap: 0.5rem; }
        .card-body { padding: 1.25rem; flex-grow: 1; }
        .card-footer { padding: 0.75rem 1.25rem; border-top: 1px solid var(--border); background-color: var(--bg-alt); }
        .card > p { margin: 0 1.25rem 1rem; color: var(--text-secondary); }
        
        /* --- Form Elements & Buttons --- */
        textarea, input[type="text"], input[type="number"] {
            width: 100%;
            padding: 0.75rem;
            border: 1px solid var(--border);
            border-radius: var(--radius-md);
            background-color: var(--bg-input);
            color: var(--text-primary);
            font-family: var(--font-sans);
            font-size: 1rem;
            transition: border-color 0.2s ease, box-shadow 0.2s ease;
        }
        textarea:focus, input:focus {
            outline: none;
            border-color: var(--border-focus);
            box-shadow: 0 0 0 3px color-mix(in srgb, var(--border-focus) 20%, transparent);
        }
        textarea { min-height: 200px; resize: vertical; }
        input[type="file"] {
            font-size: 0.9rem;
            color: var(--text-secondary);
        }
        input[type="file"]::file-selector-button {
            padding: 0.5rem 1rem;
            border: 1px solid var(--border);
            border-radius: var(--radius-md);
            background-color: var(--bg-alt);
            color: var(--text-primary);
            cursor: pointer;
            transition: background-color 0.2s ease;
            margin-right: 1rem;
        }
        input[type="file"]::file-selector-button:hover { background-color: var(--bg-active); }
        label { display: block; margin-bottom: 0.5rem; font-weight: 500; color: var(--text-secondary); }
        .checkbox-group { display: flex; align-items: center; gap: 0.5rem; margin: 0.5rem 0; }
        .checkbox-group label { margin: 0; font-weight: normal; color: var(--text-primary); }
        input[type="checkbox"] { width: 1rem; height: 1rem; accent-color: var(--text-accent); }

        button {
            padding: 0.6rem 1.25rem;
            border: none;
            border-radius: var(--radius-md);
            cursor: pointer;
            font-weight: 600;
            font-size: 0.9rem;
            transition: all 0.2s ease;
        }
        button.primary { background-color: var(--text-accent); color: var(--text-on-accent); }
        button.primary:hover { background-color: color-mix(in srgb, var(--text-accent) 85%, black); }
        button.secondary { background-color: var(--bg-active); color: var(--text-primary); border: 1px solid var(--border); }
        button.secondary:hover { background-color: color-mix(in srgb, var(--bg-active) 85%, black); }
        button:disabled { background-color: var(--bg-hover); color: var(--text-secondary); cursor: not-allowed; }
        .button-group { display: flex; flex-wrap: wrap; gap: 0.75rem; margin-top: 1rem; }
        .input-group { margin-bottom: 1.25rem; }
        
        /* --- Collapsible Section for Timeline Tools --- */
        .collapsible-section {
            border: 1px solid var(--border);
            border-radius: var(--radius-lg);
            margin-top: 1.5rem;
            background-color: var(--bg-card);
            box-shadow: var(--shadow);
            overflow: hidden;
            transition: all 0.3s ease;
        }
        .collapsible-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem 1.25rem;
            cursor: pointer;
        }
        .collapsible-header h2 { font-size: 1.25rem; margin: 0; }
        .collapsible-header .chevron {
            font-size: 1.5rem;
            transition: transform 0.3s ease;
        }
        .collapsible-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.5s ease-in-out, padding 0.5s ease-in-out;
            padding: 0 1.25rem;
            border-top: 1px solid transparent;
        }
        .collapsible-section.is-open .collapsible-content {
            max-height: 2000px; /* Large enough for content */
            padding: 1.5rem 1.25rem;
            border-top-color: var(--border);
        }
        .collapsible-section.is-open .chevron { transform: rotate(90deg); }

        /* --- Tab Component --- */
        .tab-container {
            display: flex;
            border-bottom: 1px solid var(--border);
            margin-bottom: 1.5rem;
            gap: 0.25rem;
        }
        .tab {
            padding: 0.75rem 1.25rem;
            cursor: pointer;
            background-color: transparent;
            border: 0;
            border-bottom: 2px solid transparent;
            color: var(--text-secondary);
            font-weight: 500;
            transition: all 0.2s ease;
        }
        .tab:hover { background-color: var(--bg-hover); color: var(--text-primary); }
        .tab.active {
            color: var(--text-accent);
            border-bottom-color: var(--text-accent);
            font-weight: 600;
        }
        .tab-content { display: none; }
        .tab-content.active { display: block; animation: fadeIn 0.5s ease; }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }

        /* --- Specific Component Styling --- */
        .main-actions {
            background-color: var(--bg-alt);
            border: 1px solid var(--border);
            border-radius: var(--radius-lg);
            padding: 1.25rem;
            margin-bottom: 1.5rem;
            display: flex;
            flex-wrap: wrap;
            gap: 1rem;
            align-items: center;
        }
        .input-with-overlay { position: relative; }
        .card-header .icon-btn { width: 32px; height: 32px; font-size: 1rem; }
        .time-input { font-family: monospace; }
        .example { font-size: 0.8em; color: var(--text-secondary); margin-top: 0.25rem; }
        .grid-2-col { display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 1.5rem; }
        .info-panel { background-color: var(--blue-bg); color: var(--blue-text); padding: 1rem; border-radius: var(--radius-md); margin-top: 1rem; font-size: 0.9em; line-height: 1.5; }
        #youtube-url-container { display: none; margin-top: 1rem; }
        
        /* --- Output Log Styling --- */
        #outputLog {
            background-color: var(--bg-input);
            border: 1px solid var(--border);
            border-radius: var(--radius-md);
            padding: 1rem;
            white-space: pre-wrap;
            word-wrap: break-word;
            overflow-y: auto;
            min-height: 150px;
            max-height: 400px;
            resize: vertical;
            font-size: 0.9rem;
        }
        .diff-line { margin-bottom: 1rem; border-bottom: 1px solid var(--border); padding-bottom: 1rem; }
        .diff-line:last-child { border-bottom: none; margin-bottom: 0; padding-bottom: 0; }
        .diff-line > b { cursor: pointer; color: var(--text-accent); }
        .diff-line > b:hover { text-decoration: underline; }
        .diff-label { font-weight: bold; }
        .added { background-color: var(--green-bg); color: var(--green-text); border-radius: var(--radius-sm); padding: 1px 3px; }
        .removed { background-color: var(--red-bg); color: var(--red-text); border-radius: var(--radius-sm); padding: 1px 3px; }
        #correctionSummaryContainer { margin-bottom: 1rem; display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; }
        #correctionSummary { font-weight: 500; }
        
        /* --- Floating Video Player --- */
        #floatingVideoContainer {
            position: fixed;
            top: 50px; right: 50px;
            width: 480px; height: 270px;
            min-width: 320px; min-height: 180px;
            background-color: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: var(--radius-lg);
            box-shadow: var(--shadow-lg);
            z-index: 2000;
            resize: both;
            overflow: hidden;
            display: none;
            flex-direction: column;
            transition: all 0.3s ease;
        }
        #floatingVideoContainer .window-header {
            padding: 5px 10px;
            background-color: var(--bg-alt);
            border-bottom: 1px solid var(--border);
            cursor: move;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-weight: 600;
        }
        #floatingVideoContainer .window-header .header-buttons button {
            background: none; border: none; color: var(--text-secondary);
            font-size: 1rem; padding: 4px 8px; cursor: pointer;
        }
        #floatingVideoContainer .window-header .header-buttons button:hover { color: var(--text-primary); }
        #floatingVideoContainer .window-header .header-buttons button.pinned { color: var(--text-accent); }
        #player-container { flex-grow: 1; width: 100%; background-color: #000; }
        #player-container iframe, #player-container video { width: 100%; height: 100%; border: 0; }

        /* --- Fixer Mode --- */
        body.fixer-mode-active .app-header,
        body.fixer-mode-active .collapsible-section,
        body.fixer-mode-active #card-correction-rules,
        body.fixer-mode-active #card-video-controls .card-body > p,
        body.fixer-mode-active #card-source-subtitle .card-body > p:first-of-type,
        body.fixer-mode-active #card-output .card-body > p:first-of-type,
        body.fixer-mode-active .main-actions #compareAndGenerateButton,
        body.fixer-mode-active #provideYoutubeUrlCheckbox-group {
            display: none;
        }
        body.fixer-mode-active .main-grid {
             grid-template-columns: 1fr 1fr;
        }
        body.fixer-mode-active .app-container { max-width: 100%; width: 100%; padding: 1rem; }
        body.fixer-mode-active #card-video-controls { display: block; }
        body.fixer-mode-active #subtitleText,
        body.fixer-mode-active #outputLog {
            height: 70vh;
            max-height: none;
        }

        /* --- Pinned Player Mode --- */
        body.video-fixer-mode-pinned {
            padding-top: 30vh;
        }
        body.video-fixer-mode-pinned #floatingVideoContainer {
            position: fixed;
            top: 0; left: 0; right: 0;
            width: 100%; height: 30vh;
            resize: vertical;
            min-height: 150px;
            border-radius: 0;
            border-left: 0; border-right: 0;
            box-shadow: var(--shadow-md);
            z-index: 2000;
        }
        
        /* --- Responsive Design --- */
        @media (max-width: 900px) {
            .main-grid {
                grid-template-columns: 1fr;
            }
        }
        
        /* Modal styles are inherited from the old code and should be restyled if needed, but are kept for functionality */
        .modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.6); display: none; justify-content: center; align-items: center; z-index: 3000; }
        .modal-container { background-color: var(--bg-card); padding: 25px; border-radius: var(--radius-lg); box-shadow: var(--shadow-lg); width: 90%; max-width: 700px; max-height: 80vh; display: flex; flex-direction: column; border: 1px solid var(--border); }
        .modal-header { border-bottom: 1px solid var(--border); padding-bottom: 15px; margin-bottom: 15px; }
        .modal-header h3 { margin: 0; color: var(--text-primary); }
        .modal-content { overflow-y: auto; flex-grow: 1; }
        .modal-footer { border-top: 1px solid var(--border); padding-top: 15px; margin-top: 15px; display: flex; justify-content: flex-end; gap: 10px; }
        #addedRulesModal .modal-content textarea { min-height: 50vh; }
        /* Add other modal styles from original if they have specific layouts */
        
        /* Legacy styles from original file, slightly adapted for new theme */
        .revert-controls { margin-top: 8px; padding: 8px; background-color: var(--bg-alt); border-radius: var(--radius-md); font-size: 0.9em; position: relative; }
        .revert-controls label { display: inline-flex; align-items: center; margin-right: 15px; font-weight: normal; }
        .count-tag { font-weight: normal; font-size: 0.9em; padding: 2px 5px; border-radius: var(--radius-sm); margin-left: 8px; vertical-align: middle; display: inline-block; }
        .count-tag { background-color: var(--blue-bg); color: var(--blue-text); border: 1px solid color-mix(in srgb, var(--blue-bg) 80%, black); }
        .count-tag .from { color: var(--red-text); }
        .count-tag .to { color: var(--green-text); }
        .count-tag .hidden-count a { color: var(--yellow-text); font-size: 0.9em; margin-left: 4px; cursor: pointer; }
        .inline-controls-group { display: none; font-size: 0.9em; margin-left: 10px; }
        .inline-controls-group label { display: inline-flex; align-items: center; font-weight: normal; margin-right: 15px;}
        
        /* Hiding elements that are now part of cards or the header */
        .main-nav, h1.original-h1, h2.original-h2 { display: none; }
    </style>
</head>
<body data-theme="light">
    <!-- START: FLOATING VIDEO CONTAINER (Retained original ID for JS) -->
    <div id="floatingVideoContainer">
        <div class="window-header">
            <span>å½±åƒæ’­æ”¾å™¨</span>
            <div class="header-buttons">
                <button id="pinVideoBtn" title="å°‡æ’­æ”¾å™¨å›ºå®šåœ¨ä¸Šæ–¹">ğŸ“Œ</button>
                <button id="closeVideoBtn" title="é—œé–‰æ’­æ”¾å™¨">âœ–</button>
            </div>
        </div>
        <div id="player-container">
            <div style="width: 100%; height: 100%; background: #222; display:flex; align-items:center; justify-content:center; color: #888;">è«‹è¼‰å…¥å½±ç‰‡</div>
        </div>
    </div>
    <!-- END: FLOATING VIDEO CONTAINER -->

    <div class="app-container">
        <!-- APP HEADER (New) -->
        <header class="app-header">
            <h1>å­—å¹•å…¨èƒ½å·¥å…· Pro</h1>
            <div class="header-actions">
                <a class="icon-btn" href="https://colab.research.google.com/drive/1RzNeqAA5duszSyVWL3a65eHInfwyusci#scrollTo=-U10L-FaUDPA" target="_blank" rel="noopener noreferrer" title="Whisper@Colab">ğŸš€</a>
                <button class="icon-btn" id="settingsBtn" title="é …ç›®è¨­å®š">âš™ï¸</button>
                <button class="icon-btn" id="theme-toggle" title="åˆ‡æ›ä¸»é¡Œ">
                    <span class="sun-icon">â˜€ï¸</span>
                    <span class="moon-icon">ğŸŒ™</span>
                </button>
            </div>
        </header>

        <!-- MAIN CONTENT GRID (New) -->
        <div class="main-grid" id="fixer-section">
            
            <!-- LEFT COLUMN: INPUTS -->
            <div class="input-column">
                 <!-- Video Controls Card -->
                <div class="card" id="card-video-controls" style="display:none;">
                    <div class="card-header">
                        <h2>å½±ç‰‡æ’­æ”¾æ§åˆ¶</h2>
                    </div>
                    <div class="card-body">
                        <!-- All original video control elements are kept inside for JS compatibility -->
                        <div id="video-controls-section">
                            <div class="checkbox-group">
                                <input type="checkbox" id="toggleVideoPlayerCheckbox"><label for="toggleVideoPlayerCheckbox">é¡¯ç¤ºæ’­æ”¾å™¨</label>
                            </div>
                             <div class="checkbox-group">
                                <input type="checkbox" id="pinVideoPlayerCheckbox"><label for="pinVideoPlayerCheckbox">å°‡æ’­æ”¾å™¨å›ºå®šåœ¨ä¸Šæ–¹</label>
                            </div>
                             <div class="checkbox-group">
                                <input type="checkbox" id="followVideoToggle"><label for="followVideoToggle">å­—å¹•è·Ÿéš¨å½±ç‰‡</label>
                            </div>
                            <div class="input-group" style="margin-top: 1rem;">
                                <label for="videoUrlInput">å½±ç‰‡ä¾†æº</label>
                                <div style="display: flex; gap: 10px;">
                                    <input type="text" id="videoUrlInput" placeholder="YouTubeç¶²å€æˆ–é¸æ“‡æœ¬åœ°æª”">
                                    <button id="loadVideoBtn" class="primary">è¼‰å…¥</button>
                                    <input type="file" id="localVideoFile" accept="video/*" style="display: none;">
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Source Subtitle Card -->
                <div class="card original-subtitle-group" id="card-source-subtitle">
                    <div class="card-header">
                        <h2>åŸå§‹å­—å¹•</h2>
                        <div class="card-header-actions">
                             <button id="convertSubtitleFormatButton" class="icon-btn secondary" title="SRT <-> VTT æ ¼å¼äº’æ›" style="display: none;">ğŸ”„</button>
                             <button id="downloadConvertedButton" class="icon-btn secondary" style="display: none;" title="ä¸‹è¼‰è½‰æ›çµæœ">ğŸ’¾</button>
                        </div>
                    </div>
                    <div class="card-body">
                         <p>ä¸Šå‚³å­—å¹•æª”æˆ–ç›´æ¥è²¼ä¸Šå…§å®¹ (æ”¯æ´SRT/VTT)ã€‚</p>
                        <div class="input-group">
                           <input type="file" id="subtitleFile" accept=".txt,.srt,.vtt">
                        </div>
                        <div class="checkbox-group" id="provideYoutubeUrlCheckbox-group">
                           <input type="checkbox" id="provideYoutubeUrlCheckbox"><label for="provideYoutubeUrlCheckbox">å¾Youtubeè¦–é »ç¶²å€è¼‰å…¥</label>
                        </div>
                        <div id="youtube-url-container" class="input-group">
                            <input type="text" id="mainYoutubeUrlInput" placeholder="è²¼ä¸ŠYoutubeè¦–é »é€£çµ...">
                        </div>
                        <div class="input-with-overlay">
                            <textarea id="subtitleText" placeholder="åœ¨æ­¤è²¼ä¸Šå­—å¹•å…§å®¹..."></textarea>
                            <!-- The button-overlay is replaced by card-header-actions -->
                        </div>
                    </div>
                </div>
            </div>

            <!-- RIGHT COLUMN: ACTIONS & OUTPUT -->
            <div class="action-column">
                <!-- Correction Rules Card -->
                <div class="card correction-input-group" id="card-correction-rules">
                    <div class="card-header">
                        <h2>ä¿®æ­£è¦å‰‡</h2>
                         <div class="card-header-actions">
                            <button id="convertCorrectionFormatButton" class="icon-btn secondary" title="è½‰æ›æ ¼å¼" style="display: none;">ğŸ”„</button>
                         </div>
                    </div>
                    <div class="card-body">
                         <p>ä¸Šå‚³æˆ–è²¼ä¸Šä¿®æ­£æª”ï¼Œæˆ–ä½¿ç”¨ã€Œæ¯”å°ä¿®æ­£è©ã€è‡ªå‹•ç”Ÿæˆã€‚</p>
                        <div class="input-group">
                            <input type="file" id="correctionFile" accept=".txt">
                        </div>
                        <div class="input-with-overlay">
                             <textarea id="correctionText" placeholder="è²¼ä¸Šä¿®æ­£æª”å…§å®¹..."></textarea>
                        </div>
                    </div>
                </div>
                
                <!-- Main Actions -->
                <div class="main-actions">
                    <button id="fixButton" class="primary">ä¿®æ­£å­—å¹•</button>
                    <button id="compareAndGenerateButton" class="secondary" title="1.ä¸Šå‚³èˆŠå­—å¹•&#10;2.æ¯”å°ä¿®æ­£è©(ä¸Šå‚³å·²ä¿®æ­£å­—å¹•)&#10;3.æ¯”å°å‡ºçš„çµæœé¡¯ç¤ºåœ¨ä¿®æ­£è©å€åŸŸ">æ¯”å°ä¿®æ­£è©</button>
                    <button id="toggleFixerModeBtn" class="secondary" title="å°ˆæ³¨æ¯”å°ã€ä¿®æ­£å­—å¹•çš„æ¨¡å¼">é€²å…¥ä¿®æ­£æ¨¡å¼</button>
                </div>
                
                <!-- Output Card -->
                <div class="card output-section" id="card-output">
                    <div class="card-header">
                        <h2>ä¿®æ­£çµæœ</h2>
                    </div>
                    <div class="card-body">
                        <p>ä¿®æ­£å¾Œçš„å­—å¹•å°‡é¡¯ç¤ºåœ¨é€™è£¡...</p>
                        <div id="outputLogContainer">
                            <div id="correctionSummaryContainer">
                                <p id="correctionSummary"></p>
                                <div class="inline-controls-group">
                                    <label id="hideCancelledRulesContainer">
                                        <input type="checkbox" id="hideCancelledRulesToggle">
                                        éš±è—å–æ¶ˆ/æ­¸æª”
                                    </label>
                                    <label id="removeBracketsContainer">
                                        <input type="checkbox" id="removeBrackets">
                                        å»é™¤ä¿®æ­£æ‹¬è™Ÿ
                                    </label>
                                </div>
                            </div>
                            <div id="outputLog"></div>
                            <textarea id="newlyAddedRules" style="display:none;"></textarea>
                        </div>
                    </div>
                    <div class="card-footer" id="downloadButtonsWrapper">
                        <div class="button-group" style="margin-top:0;">
                             <button id="downloadButton" class="primary">ä¸‹è¼‰ä¿®æ­£å¾Œå­—å¹•</button>
                             <button id="downloadRulesButton" class="secondary" title="ä¸‹è¼‰æœ€çµ‚ä¿®æ­£è©ã€‚&#10;æœƒä¿ç•™[æœªå–æ¶ˆ]å’Œ[å·²æ­¸æª”]çš„è¦å‰‡ï¼Œä¸¦æ¨™è¨˜è¡Œè™Ÿã€‚&#10;æœƒæ¨æ£„[å·²å–æ¶ˆ]çš„è¦å‰‡ã€‚">ä¸‹è¼‰æœ€çµ‚ä¿®æ­£è©</button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- COLLAPSIBLE TIMELINE TOOLS (New) -->
            <div class="grid-span-2">
                <div class="collapsible-section" id="timeline-section-wrapper">
                    <div class="collapsible-header">
                        <h2>æ™‚é–“è»¸å·¥å…·</h2>
                        <span class="chevron">â–¶</span>
                    </div>
                    <div class="collapsible-content">
                        <!-- Original timeline section content is moved here -->
                        <div id="timeline-section">
                            <div class="tab-container">
                                <div class="tab active" onclick="openTab(event, 'directAdjust')">ç›´æ¥èª¿æ•´</div>
                                <div class="tab" onclick="openTab(event, 'anchorSync')">éŒ¨é»åŒæ­¥</div>
                                <div class="tab" onclick="openTab(event, 'subtitleCut')">å­—å¹•åˆ‡å‰²</div>
                                <div class="tab" onclick="openTab(event, 'subtitleMerge')">å­—å¹•åˆä½µ</div>
                            </div>

                            <div id="directAdjust" class="tab-content active">
                                <div class="grid-2-col">
                                    <div class="input-group">
                                        <label for="timeShift">æ™‚é–“åç§» (æ ¼å¼: +/-HH:MM:SS,ms)</label>
                                        <input type="text" id="timeShift" class="time-input" value="00:00:00,000" pattern="^-?\d{2}:\d{2}:\d{2},\d{3}$">
                                        <p class="example">ç¯„ä¾‹: -00:01:43,060 (ææ—©) æˆ– 00:00:10,000 (å»¶å¾Œ)</p>
                                    </div>
                                    <div class="input-group">
                                        <label for="speedFactorDirect">é€Ÿç‡å› å­</label>
                                        <input type="number" id="speedFactorDirect" value="1.0" step="0.01" min="0.1">
                                        <p class="example">ç¯„ä¾‹: 1.1 (åŠ é€Ÿ10%) æˆ– 0.9 (æ¸›é€Ÿ10%)</p>
                                    </div>
                                </div>
                                <div class="button-group">
                                    <button id="applyDirectAdjust" class="primary">æ‡‰ç”¨èª¿æ•´</button>
                                    <button id="downloadDirectAdjustBtn" class="secondary">ä¸‹è¼‰çµæœ</button>
                                </div>
                            </div>

                            <div id="anchorSync" class="tab-content">
                                <div class="grid-2-col">
                                    <div class="input-group">
                                        <label for="originalStart">åŸå§‹å­—å¹•èµ·å§‹æ™‚é–“ (è‡ªå‹•åµæ¸¬):</label>
                                        <input type="text" id="originalStart" class="time-input" value="00:00:00,000" pattern="^\d{2}:\d{2}:\d{2},\d{3}$">
                                        <label for="originalEnd" style="margin-top:10px;">åŸå§‹å­—å¹•çµæŸæ™‚é–“ (è‡ªå‹•åµæ¸¬):</label>
                                        <input type="text" id="originalEnd" class="time-input" value="00:00:00,000" pattern="^\d{2}:\d{2}:\d{2},\d{3}$">
                                    </div>
                                    <div class="input-group">
                                        <label for="targetStart">å°ç…§å½±ç‰‡èµ·å§‹æ™‚é–“:</label>
                                        <input type="text" id="targetStart" class="time-input" value="00:00:00,000" pattern="^\d{2}:\d{2}:\d{2},\d{3}$">
                                        <label for="targetEnd" style="margin-top:10px;">å°ç…§å½±ç‰‡çµæŸæ™‚é–“:</label>
                                        <input type="text" id="targetEnd" class="time-input" value="00:00:00,000" pattern="^\d{2}:\d{2}:\d{2},\d{3}$">
                                    </div>
                                </div>
                                <button id="calculateSync" class="primary">è¨ˆç®—åŒæ­¥åƒæ•¸</button>
                                <div class="info-panel" id="syncInfo">è«‹è¨­å®šå››å€‹æ™‚é–“éŒ¨é»å¾Œé»æ“Šè¨ˆç®—ã€‚</div>
                                 <div class="button-group">
                                    <button id="applyAnchorSync" disabled class="primary">æ‡‰ç”¨åŒæ­¥</button>
                                    <button id="downloadAnchorSyncBtn" class="secondary" disabled>ä¸‹è¼‰çµæœ</button>
                                </div>
                            </div>

                            <div id="subtitleCut" class="tab-content">
                                 <div class="grid-2-col">
                                    <div class="input-group">
                                        <label for="cutStart">åˆ‡å‰²èµ·å§‹æ™‚é–“ (æ­¤æ™‚é–“é»å°‡è®Šç‚º 00:00:00,000)</label>
                                        <input type="text" id="cutStart" class="time-input" value="00:00:00,000">
                                        <label for="cutStartLine" style="margin-top:10px;">åˆ‡å‰²èµ·å§‹è¡Œè™Ÿ</label>
                                        <input type="number" id="cutStartLine" min="1" value="1">
                                    </div>
                                    <div class="input-group">
                                        <label for="cutEnd">åˆ‡å‰²çµæŸæ™‚é–“ (è‡ªå‹•åµæ¸¬)</label>
                                        <input type="text" id="cutEnd" class="time-input" value="00:00:00,000">
                                         <label for="cutEndLine" style="margin-top:10px;">åˆ‡å‰²çµæŸè¡Œè™Ÿ (è‡ªå‹•åµæ¸¬)</label>
                                        <input type="number" id="cutEndLine" min="1" value="1">
                                    </div>
                                </div>
                                <div class="button-group">
                                    <button id="applyCut" class="primary">æ‡‰ç”¨åˆ‡å‰²</button>
                                    <button id="downloadCutBtn" class="secondary">ä¸‹è¼‰çµæœ</button>
                                </div>
                            </div>
                            
                            <div id="subtitleMerge" class="tab-content">
                                <p>è«‹ä¸Šå‚³å…©å€‹å­—å¹•æª”é€²è¡Œåˆä½µã€‚æª”æ¡ˆ2çš„æ™‚é–“è»¸å°‡æœƒæ¥çºŒåœ¨æª”æ¡ˆ1çš„çµå°¾ä¹‹å¾Œã€‚</p>
                                <div class="grid-2-col">
                                    <div class="input-group">
                                        <label for="mergeFile1">æª”æ¡ˆ 1 (åŸºç¤å­—å¹•)</label>
                                        <input type="file" id="mergeFile1" accept=".txt,.srt,.vtt">
                                        <textarea id="mergeFile1Content" rows="5" placeholder="æª”æ¡ˆ1å…§å®¹é è¦½..."></textarea>
                                    </div>
                                    <div class="input-group">
                                        <label for="mergeFile2">æª”æ¡ˆ 2 (è¦é™„åŠ çš„å­—å¹•)</label>
                                        <input type="file" id="mergeFile2" accept=".txt,.srt,.vtt">
                                        <textarea id="mergeFile2Content" rows="5" placeholder="æª”æ¡ˆ2å…§å®¹é è¦½..."></textarea>
                                    </div>
                                </div>
                                <div class="button-group">
                                    <button id="mergeSubtitlesBtn" class="primary">åˆä½µå­—å¹•</button>
                                    <button id="downloadMergedBtn" class="secondary">ä¸‹è¼‰åˆä½µæª”</button>
                                    <button id="addAndMergeBtn" class="secondary" style="display: none;" title="å°‡æª”æ¡ˆ1å’Œæª”æ¡ˆ2çš„åˆä½µçµæœæ”¾å›æª”æ¡ˆ1ï¼Œä»¥ç¹¼çºŒåˆä½µä¸‹ä¸€å€‹æª”æ¡ˆ">+ é™„åŠ è‡³æª”æ¡ˆ1</button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- ALL MODALS - Kept original markup for JS compatibility, but they will inherit new styles -->
    <!-- START: MODAL MARKUP -->
    <div id="correctionModal" class="modal-overlay"> <div class="modal-container"> <div class="modal-header"> <h3 id="modalTitle">ç®¡ç†ä¿®æ­£</h3> </div> <div class="modal-content"> <ul id="modalCorrectionList"></ul> </div> <div class="modal-footer"> <button id="modalSelectAll" class="secondary">å…¨é¸</button> <button id="modalDeselectAll" class="secondary">å…¨ä¸é¸</button> <button id="modalApplyBtn" class="primary">æ‡‰ç”¨é¸æ“‡</button> <button id="modalCloseBtn" class="secondary">é—œé–‰</button> </div> </div> </div>
    <div id="ruleManagementModal" class="modal-overlay"> <div class="modal-container"> <div class="modal-header"> <h3 id="ruleManagementModalTitle">ç®¡ç†è¦å‰‡</h3> </div> <div class="modal-content"> <ul id="ruleManagementModalList"></ul> </div> <div class="modal-footer"> <button id="ruleManagementSelectAll" class="secondary">å…¨é¸</button> <button id="ruleManagementDeselectAll" class="secondary">å…¨ä¸é¸</button> <button id="ruleManagementArchiveBtn" class="secondary">æ­¸æª”å·²é¸</button> <button id="ruleManagementApplyBtn" class="primary">æ‡‰ç”¨é¸æ“‡</button> <button id="ruleManagementCloseBtn" class="secondary">é—œé–‰</button> </div> </div> </div>
    <div id="addedRulesModal" class="modal-overlay"> <div class="modal-container"> <div class="modal-header"> <h3>ç·¨è¼¯æ‰‹å‹•æ–°å¢çš„è¦å‰‡</h3> </div> <div class="modal-content"> <textarea id="addedRulesTextarea"></textarea> </div> <div class="modal-footer"> <button id="addedRulesSaveChangesBtn" class="primary">å„²å­˜è®Šæ›´</button> <button id="addedRulesCloseBtn" class="secondary">é—œé–‰</button> </div> </div> </div>
    <div id="newRuleModal" class="modal-overlay"> <div class="modal-container" style="max-width: 550px;"> <div class="modal-header"> <h3 id="newRuleModalTitle">æ–°å¢ä¿®æ­£è¦å‰‡</h3> </div> <div class="modal-content"> <div id="newRuleFormContainer"></div> </div> <div class="modal-footer" style="justify-content: space-between;"> <button id="listAddedRulesBtn" class="secondary">åˆ—å‡ºå·²æ–°å¢è¦å‰‡</button> <div><button id="newRuleConfirmBtn" class="primary">ç¢ºèªæ–°å¢</button> <button id="newRuleCloseBtn" class="secondary">å–æ¶ˆ</button></div> </div> </div> </div>
    <div id="settingsModal" class="modal-overlay"> <div class="modal-container" style="max-width: 500px;"> <div class="modal-header"> <h3>é …ç›®è¨­å®š</h3> </div> <div class="modal-content"> <div class="setting-item"> <label for="windowStackingToggle"> <input type="checkbox" id="windowStackingToggle"> é–‹å•Ÿè¦–çª—éšç´š (è¿”å›ä¸Šä¸€å±¤è¦–çª—) </label> <p class="example">å•Ÿç”¨å¾Œï¼Œå¾ä¸€å€‹è¦–çª—é»æ“Šé€£çµé–‹å•Ÿæ–°è¦–çª—ï¼Œé—œé–‰æ™‚æœƒå›åˆ°å‰ä¸€å€‹è¦–çª—ã€‚</p> </div> <div class="setting-item"> <label for="defaultShowRevertToggle"> <input type="checkbox" id="defaultShowRevertToggle"> é è¨­ç‚ºé¡¯ç¤ºä¿®æ”¹é¸é … </label> <p class="example">å•Ÿç”¨å¾Œï¼Œã€Œä¿®æ­£å­—å¹•ã€çš„çµæœæœƒé è¨­å±•é–‹æ¯å€‹é …ç›®çš„ä¿®æ”¹é¸é …ã€‚</p> </div> </div> <div class="modal-footer"> <button id="settingsCloseBtn" class="secondary">é—œé–‰</button> </div> </div> </div>
    <!-- END: MODAL MARKUP -->

    <script>
    // --- START: NEW UI CONTROL SCRIPT ---
    document.addEventListener('DOMContentLoaded', () => {
        // Theme Toggle
        const themeToggle = document.getElementById('theme-toggle');
        const currentTheme = localStorage.getItem('theme') || 'light';
        document.body.setAttribute('data-theme', currentTheme);

        themeToggle.addEventListener('click', () => {
            let newTheme = document.body.getAttribute('data-theme') === 'light' ? 'dark' : 'light';
            document.body.setAttribute('data-theme', newTheme);
            localStorage.setItem('theme', newTheme);
        });

        // Collapsible Section
        const collapsibleHeader = document.querySelector('.collapsible-header');
        const collapsibleSection = document.querySelector('.collapsible-section');
        collapsibleHeader.addEventListener('click', () => {
            collapsibleSection.classList.toggle('is-open');
        });
    });
    // --- END: NEW UI CONTROL SCRIPT ---


    // --- ORIGINAL SCRIPT (UNCHANGED except for moving some element assignments) ---
    // All of your original JavaScript is placed here. I've confirmed all IDs are intact.
    // The only minor adjustments are related to element selections that might have moved in the new layout.
    document.addEventListener('DOMContentLoaded', () => {
        // --- Elements Declarations ---
        const settingsBtn = document.getElementById('settingsBtn');
        const settingsModal = document.getElementById('settingsModal');
        const windowStackingToggle = document.getElementById('windowStackingToggle');
        const settingsCloseBtn = document.getElementById('settingsCloseBtn');
        const defaultShowRevertToggle = document.getElementById('defaultShowRevertToggle');
        const subtitleFile = document.getElementById('subtitleFile');
        const subtitleText = document.getElementById('subtitleText');
        const correctionFile = document.getElementById('correctionFile');
        const correctionText = document.getElementById('correctionText');
        const fixButton = document.getElementById('fixButton');
        const convertCorrectionFormatButton = document.getElementById('convertCorrectionFormatButton');
        const compareAndGenerateButton = document.getElementById('compareAndGenerateButton');
        const correctionSummary = document.getElementById('correctionSummary');
        const outputLogContainer = document.getElementById('outputLogContainer');
        const hideCancelledRulesToggle = document.getElementById('hideCancelledRulesToggle');
        const outputLog = document.getElementById('outputLog');
        const removeBrackets = document.getElementById('removeBrackets');
        const downloadButton = document.getElementById('downloadButton');
        const downloadRulesButton = document.getElementById('downloadRulesButton');
        const convertSubtitleFormatButton = document.getElementById('convertSubtitleFormatButton');
        const downloadConvertedButton = document.getElementById('downloadConvertedButton');
        const newlyAddedRules = document.getElementById('newlyAddedRules');
        const toggleFixerModeBtn = document.getElementById('toggleFixerModeBtn');
        const timeShiftInput = document.getElementById('timeShift');
        const speedFactorDirectInput = document.getElementById('speedFactorDirect');
        const applyDirectAdjustBtn = document.getElementById('applyDirectAdjust');
        const downloadDirectAdjustBtn = document.getElementById('downloadDirectAdjustBtn');
        const originalStartInput = document.getElementById('originalStart');
        const originalEndInput = document.getElementById('originalEnd');
        const targetStartInput = document.getElementById('targetStart');
        const targetEndInput = document.getElementById('targetEnd');
        const calculateSyncBtn = document.getElementById('calculateSync');
        const syncInfoPanel = document.getElementById('syncInfo');
        const applyAnchorSyncBtn = document.getElementById('applyAnchorSync');
        const downloadAnchorSyncBtn = document.getElementById('downloadAnchorSyncBtn');
        const cutStartInput = document.getElementById('cutStart');
        const cutEndInput = document.getElementById('cutEnd');
        const cutStartLineInput = document.getElementById('cutStartLine');
        const cutEndLineInput = document.getElementById('cutEndLine');
        const applyCutBtn = document.getElementById('applyCut');
        const downloadCutBtn = document.getElementById('downloadCutBtn');
        const mergeFile1Input = document.getElementById('mergeFile1');
        const mergeFile2Input = document.getElementById('mergeFile2');
        const mergeFile1Content = document.getElementById('mergeFile1Content');
        const mergeFile2Content = document.getElementById('mergeFile2Content');
        const mergeSubtitlesBtn = document.getElementById('mergeSubtitlesBtn');
        const downloadMergedBtn = document.getElementById('downloadMergedBtn');
        const addAndMergeBtn = document.getElementById('addAndMergeBtn');
        const correctionModal = document.getElementById('correctionModal');
        const modalTitle = document.getElementById('modalTitle');
        const modalCorrectionList = document.getElementById('modalCorrectionList');
        const modalSelectAll = document.getElementById('modalSelectAll');
        const modalDeselectAll = document.getElementById('modalDeselectAll');
        const modalApplyBtn = document.getElementById('modalApplyBtn');
        const modalCloseBtn = document.getElementById('modalCloseBtn');
        const addedRulesModal = document.getElementById('addedRulesModal');
        const addedRulesTextarea = document.getElementById('addedRulesTextarea');
        const addedRulesSaveChangesBtn = document.getElementById('addedRulesSaveChangesBtn');
        const addedRulesCloseBtn = document.getElementById('addedRulesCloseBtn');
        const newRuleModal = document.getElementById('newRuleModal');
        const newRuleModalTitle = document.getElementById('newRuleModalTitle');
        const newRuleFormContainer = document.getElementById('newRuleFormContainer');
        const listAddedRulesBtn = document.getElementById('listAddedRulesBtn');
        const newRuleConfirmBtn = document.getElementById('newRuleConfirmBtn');
        const newRuleCloseBtn = document.getElementById('newRuleCloseBtn');
        const ruleManagementModal = document.getElementById('ruleManagementModal');
        const ruleManagementModalTitle = document.getElementById('ruleManagementModalTitle');
        const ruleManagementModalList = document.getElementById('ruleManagementModalList');
        const ruleManagementSelectAll = document.getElementById('ruleManagementSelectAll');
        const ruleManagementDeselectAll = document.getElementById('ruleManagementDeselectAll');
        const ruleManagementArchiveBtn = document.getElementById('ruleManagementArchiveBtn');
        const ruleManagementApplyBtn = document.getElementById('ruleManagementApplyBtn');
        const ruleManagementCloseBtn = document.getElementById('ruleManagementCloseBtn');
        const provideYoutubeUrlCheckbox = document.getElementById('provideYoutubeUrlCheckbox');
        const youtubeUrlContainer = document.getElementById('youtube-url-container');
        const mainYoutubeUrlInput = document.getElementById('mainYoutubeUrlInput');
        const inlineControlsGroup = document.querySelector('.inline-controls-group');
        
        // --- Video Player Elements ---
        const floatingVideoContainer = document.getElementById('floatingVideoContainer');
        const videoHeader = floatingVideoContainer.querySelector('.window-header');
        const pinVideoBtn = document.getElementById('pinVideoBtn');
        const closeVideoBtn = document.getElementById('closeVideoBtn');
        const toggleVideoPlayerCheckbox = document.getElementById('toggleVideoPlayerCheckbox');
        const pinVideoPlayerCheckbox = document.getElementById('pinVideoPlayerCheckbox');
        const videoUrlInput = document.getElementById('videoUrlInput');
        const loadVideoBtn = document.getElementById('loadVideoBtn');
        const localVideoFile = document.getElementById('localVideoFile');
        const playerContainer = document.getElementById('player-container');
        const videoControlsSection = document.getElementById('video-controls-section');
        const cardVideoControls = document.getElementById('card-video-controls'); // New element
        const followVideoToggle = document.getElementById('followVideoToggle');
        
        // --- Global State Variables ---
        let correctedSubtitle = "";
        let lastCalculatedParams = null;
        let appliedCorrectionsData = {};
        let totalCorrectionsCount = 0;
        let isWindowStackingEnabled = false;
        let isDefaultShowRevertEnabled = false;
        let modalStack = []; 
        let currentPlayer = { player: null, type: null, isReady: false }; 
        let currentParsedSubs = [];
        let followInterval = null;
        let lastActiveLineIndex = -1;

        // --- Setting Persistence Logic ---
        function saveSettings() {
            isWindowStackingEnabled = windowStackingToggle.checked;
            isDefaultShowRevertEnabled = defaultShowRevertToggle.checked;
            localStorage.setItem('windowStackingEnabled', isWindowStackingEnabled);
            localStorage.setItem('defaultShowRevert', isDefaultShowRevertEnabled);
        }

        function loadSettings() {
            const stackingEnabled = localStorage.getItem('windowStackingEnabled') === 'true';
            isWindowStackingEnabled = stackingEnabled;
            windowStackingToggle.checked = stackingEnabled;
            const defaultShowRevert = localStorage.getItem('defaultShowRevert') === 'true';
            isDefaultShowRevertEnabled = defaultShowRevert;
            defaultShowRevertToggle.checked = defaultShowRevert;
        }

        // --- Window Stacking Logic (Robust) ---
        function openModal(modalElement) {
            if (isWindowStackingEnabled && modalStack.length > 0) {
                const currentTopModal = modalStack[modalStack.length - 1];
                if(currentTopModal !== modalElement) {
                    currentTopModal.style.display = 'none';
                }
            } else {
                closeAllModals();
            }

            if (modalStack[modalStack.length - 1] !== modalElement) {
                 modalStack.push(modalElement);
            }
            modalElement.style.display = 'flex';
        }

        function closeModal(modalElement) {
            if (!modalElement || modalElement.style.display === 'none') return; 
            modalElement.style.display = 'none';
            if (modalStack.length > 0 && modalStack[modalStack.length - 1] === modalElement) {
                modalStack.pop();
            }

            if (isWindowStackingEnabled && modalStack.length > 0) {
                const previousModal = modalStack[modalStack.length - 1];
                previousModal.style.display = 'flex';
            } else if (!isWindowStackingEnabled) {
                closeAllModals();
            }
        }
        
        function closeAllModals() {
            [correctionModal, ruleManagementModal, newRuleModal, addedRulesModal, settingsModal].forEach(m => {
                if(m) m.style.display = 'none'
            });
            modalStack = []; 
        }

        // --- Video Player Logic ---
        function getYouTubeVideoId(url) {
            const regExp = /^.*(youtu.be\/|v\/|u\/\w\/|embed\/|watch\?v=|\&v=)([^#\&\?]*).*/;
            const match = url.match(regExp);
            return (match && match[2].length === 11) ? match[2] : null;
        }

        function onPlayerStateChange(event) {
            if (event.data == YT.PlayerState.PLAYING) {
                startFollow();
            } else {
                stopFollow();
            }
        }
        function onPlayerReady(event) {
            currentPlayer.isReady = true;
        }
        
        function cleanupCurrentPlayer() {
            if (currentPlayer.player) {
                if (currentPlayer.type === 'youtube' && typeof currentPlayer.player.destroy === 'function') {
                    currentPlayer.player.destroy();
                } else if (currentPlayer.type === 'local') {
                    currentPlayer.player.removeEventListener('play', startFollow);
                    currentPlayer.player.removeEventListener('pause', stopFollow);
                    currentPlayer.player.removeEventListener('ended', stopFollow);
                }
            }
            playerContainer.innerHTML = '';
            currentPlayer = { player: null, type: null, isReady: false };
        }

        function loadVideo() {
            cleanupCurrentPlayer();

            const url = videoUrlInput.value.trim();
            const videoId = getYouTubeVideoId(url);
            if (videoId) {
                playerContainer.innerHTML = '<div id="yt-player-container-inner"></div>';
                currentPlayer.player = new YT.Player('yt-player-container-inner', {
                    height: '100%',
                    width: '100%',
                    videoId: videoId,
                    playerVars: { 'playsinline': 1 },
                    events: { 'onReady': onPlayerReady, 'onStateChange': onPlayerStateChange }
                });
                currentPlayer.type = 'youtube';
                floatingVideoContainer.style.display = 'flex';
                toggleVideoPlayerCheckbox.checked = true;
            } else {
                localVideoFile.click();
            }
        }

        function loadLocalVideo(event) {
            cleanupCurrentPlayer();

            const file = event.target.files[0];
            if (!file) return;
            
            const videoElement = document.createElement('video');
            videoElement.id = 'local-player';
            videoElement.controls = true;
            videoElement.src = URL.createObjectURL(file);
            playerContainer.appendChild(videoElement);
            
            currentPlayer.player = videoElement;
            currentPlayer.type = 'local';
            currentPlayer.isReady = true;

            videoElement.addEventListener('play', startFollow);
            videoElement.addEventListener('pause', stopFollow);
            videoElement.addEventListener('ended', stopFollow);

            const fileName = file.name.length > 30 ? file.name.substring(0, 27) + '...' : file.name;
            videoUrlInput.value = `æœ¬åœ°æª”æ¡ˆ: ${fileName}`;
            mainYoutubeUrlInput.value = videoUrlInput.value;
            floatingVideoContainer.style.display = 'flex';
            toggleVideoPlayerCheckbox.checked = true;
        }
        
        function seekAndPlay(seconds) {
            if (!currentPlayer.player || !currentPlayer.isReady || floatingVideoContainer.style.display === 'none') {
                console.warn("Player not loaded/ready or hidden. Cannot seek.");
                return;
            }
            
            if (currentPlayer.type === 'youtube' && typeof currentPlayer.player.seekTo === 'function') {
                currentPlayer.player.seekTo(seconds, true);
                currentPlayer.player.playVideo();
            } else if (currentPlayer.type === 'local') {
                currentPlayer.player.currentTime = seconds;
                currentPlayer.player.play();
            }
        }
        
        // --- Dragging Logic for Floating Window ---
        let isDragging = false;
        let offsetX, offsetY;
        videoHeader.addEventListener('mousedown', (e) => {
            if (e.target.closest('button') || document.body.classList.contains('video-fixer-mode-pinned')) return;
            isDragging = true;
            offsetX = e.clientX - floatingVideoContainer.offsetLeft;
            offsetY = e.clientY - floatingVideoContainer.offsetTop;
            document.addEventListener('mousemove', onDragMove);
            document.addEventListener('mouseup', onDragEnd);
        });

        function onDragMove(e) {
            if (!isDragging) return;
            e.preventDefault();
            let newX = e.clientX - offsetX;
            let newY = e.clientY - offsetY;
            floatingVideoContainer.style.left = `${newX}px`;
            floatingVideoContainer.style.top = `${newY}px`;
        }

        function onDragEnd() {
            isDragging = false;
            document.removeEventListener('mousemove', onDragMove);
            document.removeEventListener('mouseup', onDragEnd);
        }

        // --- Toggling Visibility & Pinning ---
        function setPlayerPinned(isPinned) {
            pinVideoPlayerCheckbox.checked = isPinned;
            pinVideoBtn.classList.toggle('pinned', isPinned);
            
            const isInFixerMode = document.body.classList.contains('fixer-mode-active');
            if (isPinned && isInFixerMode) {
                document.body.classList.add('video-fixer-mode-pinned');
                floatingVideoContainer.style.left = '';
                floatingVideoContainer.style.top = '';
            } else {
                document.body.classList.remove('video-fixer-mode-pinned');
            }
        }

        toggleVideoPlayerCheckbox.addEventListener('change', () => {
            floatingVideoContainer.style.display = toggleVideoPlayerCheckbox.checked ? 'flex' : 'none';
        });
        closeVideoBtn.addEventListener('click', () => {
            floatingVideoContainer.style.display = 'none';
            toggleVideoPlayerCheckbox.checked = false;
        });
        pinVideoPlayerCheckbox.addEventListener('change', () => {
            setPlayerPinned(pinVideoPlayerCheckbox.checked);
        });
        pinVideoBtn.addEventListener('click', () => {
            setPlayerPinned(!pinVideoPlayerCheckbox.checked);
        });
        
        // --- Main YouTube URL Input Logic ---
        provideYoutubeUrlCheckbox.addEventListener('change', () => {
            youtubeUrlContainer.style.display = provideYoutubeUrlCheckbox.checked ? 'block' : 'none';
        });
        
        function syncAndCleanUrl(sourceInput, targetInput) {
            const url = sourceInput.value.trim();
            const videoId = getYouTubeVideoId(url);
            let cleanUrl = url;
            if (videoId) {
                cleanUrl = `https://www.youtube.com/watch?v=${videoId}`;
            }
            
            if(sourceInput.value !== cleanUrl) {
                sourceInput.value = cleanUrl;
            }
            if(targetInput.value !== cleanUrl) {
                targetInput.value = cleanUrl;
            }
        }

        mainYoutubeUrlInput.addEventListener('input', () => syncAndCleanUrl(mainYoutubeUrlInput, videoUrlInput));
        videoUrlInput.addEventListener('input', () => syncAndCleanUrl(videoUrlInput, mainYoutubeUrlInput));

        // Helper Functions...
        function readFile(file, textarea, callback) { if (file) { const reader = new FileReader(); reader.onload = (e) => { textarea.value = e.target.result; if(callback) callback(); }; reader.readAsText(file, 'UTF-8'); } }
        function downloadFile(content, fileName, contentType) { const blob = new Blob([content], { type: contentType }); const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; a.download = fileName; document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url); }
        function escapeRegExp(string) { return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'); }
        function getFileName(fileInput, defaultName) { return fileInput.files[0] ? fileInput.files[0].name : defaultName; }
        
        // Time Utility Functions...
        function timeToMs(timeStr) {
            if (!timeStr) return 0;
            let isNegative = false;
            if (timeStr.startsWith('-')) { isNegative = true; timeStr = timeStr.substring(1); }
            const parts = timeStr.split(/[:,]/);
            if (parts.length !== 4) return 0;
            const [hh, mm, ss, ms] = parts.map(Number);
            const totalMs = (hh * 3600 + mm * 60 + ss) * 1000 + ms;
            return isNegative ? -totalMs : totalMs;
        }

        function parseFlexibleTimestamp(timeStr) {
            if (!timeStr) return NaN;
            timeStr = timeStr.trim().replace(',', '.');
            const timeParts = timeStr.split(':');
            let hh = 0, mm = 0, ss_ms;

            if (timeParts.length === 3) { // HH:MM:SS.ms
                hh = parseFloat(timeParts[0]);
                mm = parseFloat(timeParts[1]);
                ss_ms = timeParts[2];
            } else if (timeParts.length === 2) { // MM:SS.ms
                mm = parseFloat(timeParts[0]);
                ss_ms = timeParts[1];
            } else if (timeParts.length === 1) { // SS.ms
                ss_ms = timeParts[0];
            } else {
                return NaN;
            }

            const [ss, ms_str] = (ss_ms || "0").split('.');
            const ms = parseInt((ms_str || "0").padEnd(3, '0').substring(0, 3), 10);

            const totalMs = (hh * 3600 + mm * 60 + parseFloat(ss)) * 1000 + ms;
            return isNaN(totalMs) ? NaN : Math.round(totalMs);
        }

        function msToTime(ms, showSign = false) {
            const sign = ms < 0 ? '-' : (showSign ? '+' : '');
            ms = Math.abs(Math.round(ms));
            const hh = Math.floor(ms / 3600000); ms %= 3600000;
            const mm = Math.floor(ms / 60000); ms %= 60000;
            const ss = Math.floor(ms / 1000); ms %= 1000;
            const pad = (num, len) => String(num).padStart(len, '0');
            return `${sign}${pad(hh, 2)}:${pad(mm, 2)}:${pad(ss, 2)},${pad(ms, 3)}`;
        }
        function scrollToElement(element) { element.scrollIntoView({ behavior: 'smooth', block: 'start' }); element.focus({preventScroll:true}); }
        
        function handleSubtitleTextChange() {
            currentParsedSubs = parseSubtitle(subtitleText.value);
            toggleSubtitleButtons();
            autoPopulateTimelineFields();
        }
        correctionFile.addEventListener('change', () => readFile(correctionFile.files[0], correctionText, toggleCorrectionButtons));
        subtitleFile.addEventListener('change', () => readFile(subtitleFile.files[0], subtitleText, handleSubtitleTextChange));
        subtitleText.addEventListener('input', handleSubtitleTextChange);
        correctionText.addEventListener('input', toggleCorrectionButtons);
        
        function toggleSubtitleButtons() { const hasText = subtitleText.value.trim().length > 0; convertSubtitleFormatButton.style.display = hasText ? 'inline-block' : 'none'; downloadConvertedButton.style.display = 'none'; }
        
        function detectCorrectionFormat(text) {
            const trimmedText = text.trim();
            if (trimmedText.includes("-<") && trimmedText.includes("[") && trimmedText.includes("]>")) { return 'new'; }
            if (trimmedText.includes("- åŸå§‹å­—å¹•å…§å®¹ï¼š") || trimmedText.includes("- å»ºè­°ä¿®æ­£å…§å®¹ï¼š")) { return 'old'; }
            return 'unknown';
        }

        function toggleCorrectionButtons() {
            const text = correctionText.value;
            const format = detectCorrectionFormat(text);
            if (format === 'unknown') { convertCorrectionFormatButton.style.display = 'none'; return; }
            if (format === 'old') {
                convertCorrectionFormatButton.title = 'å°‡èˆŠæ ¼å¼ (- åŸå§‹å­—å¹•å…§å®¹...) è½‰æ›ç‚ºæ–°æ ¼å¼ (-<...[...]>)';
            } else { // 'new'
                convertCorrectionFormatButton.title = 'å°‡æ–°æ ¼å¼ (-<...[...]>) è½‰æ›ç‚ºèˆŠæ ¼å¼ (- åŸå§‹å­—å¹•å…§å®¹...)';
            }
            convertCorrectionFormatButton.style.display = 'inline-block';
        }

        let isUpdatingCutFields = false;
        function autoPopulateTimelineFields() {
            const parsedData = currentParsedSubs;
            if (isUpdatingCutFields) return;
            if (parsedData.length > 0) {
                const firstItem = parsedData[0];
                const lastItem = parsedData[parsedData.length - 1];
                const firstStartTimeSrt = (firstItem.originalFormat === 'formatSrt') ? firstItem.start : vttLikeTimeToSrt(firstItem.start);
                const lastEndTimeSrt = (lastItem.originalFormat === 'formatSrt') ? lastItem.end : vttLikeTimeToSrt(lastItem.end);
                
                originalStartInput.value = firstStartTimeSrt;
                originalEndInput.value = lastEndTimeSrt;
                cutStartInput.value = '00:00:00,000'; 
                cutEndInput.value = lastEndTimeSrt;

                cutStartLineInput.value = 1;
                cutEndLineInput.value = parsedData.length;
                cutEndLineInput.max = parsedData.length;
                cutStartLineInput.max = parsedData.length;
            } else {
                const defaultTime = '00:00:00,000';
                originalStartInput.value = defaultTime;
                originalEndInput.value = defaultTime;
                cutStartInput.value = defaultTime;
                cutEndInput.value = defaultTime;
                cutStartLineInput.value = 1;
                cutEndLineInput.value = 1;
            }
        }
        
        window.openTab = function(evt, tabName) {
            evt.currentTarget.parentElement.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            evt.currentTarget.classList.add('active');
            
            const tabContainer = evt.currentTarget.parentElement.nextElementSibling;
            while(tabContainer && !tabContainer.classList.contains('tab-content')){
                tabContainer = tabContainer.nextElementSibling;
            }
            if(tabContainer){
                let currentTab = document.getElementById(tabName);
                if(currentTab) {
                    Array.from(currentTab.parentElement.children).forEach(el => {
                       if(el.classList.contains('tab-content')) el.classList.remove('active');
                    });
                    currentTab.classList.add('active');
                }
            }
        }

        function adjustSubtitleTime(parsedData, timeShiftMs, speedFactor) { if (isNaN(timeShiftMs) || isNaN(speedFactor) || speedFactor <= 0) { alert("æ™‚é–“åç§»æˆ–é€Ÿç‡å› å­ç„¡æ•ˆã€‚"); return null; } const adjustedData = JSON.parse(JSON.stringify(parsedData)); const timeParser = (ts, format) => (format === 'formatSrt' ? timeToMs(ts) : timeToMs(vttLikeTimeToSrt(ts))); adjustedData.forEach(item => { let startMs = timeParser(item.start, item.originalFormat); let endMs = timeParser(item.end, item.originalFormat); startMs = (startMs / speedFactor) + timeShiftMs; endMs = (endMs / speedFactor) + timeShiftMs; let newStartStr = msToTime(startMs); let newEndStr = msToTime(endMs); if(item.originalFormat === 'formatVttLike') { newStartStr = srtTimeToVttLike(newStartStr); newEndStr = srtTimeToVttLike(newEndStr); } item.start = newStartStr; item.end = newEndStr; }); return adjustedData; }
        
        function getAdjustedSubtitle() {
            const parsedData = currentParsedSubs;
            if (parsedData.length === 0) { alert("ç„¡æ³•è§£æä¸Šæ–¹å­—å¹•å…§å®¹ã€‚"); return null; }
            const timeShiftMs = timeToMs(timeShiftInput.value);
            const speedFactor = parseFloat(speedFactorDirectInput.value);
            const adjustedData = adjustSubtitleTime(parsedData, timeShiftMs, speedFactor);
            if (adjustedData) return { content: rebuildSubtitle(adjustedData) };
            return null;
        }
        applyDirectAdjustBtn.addEventListener('click', () => {
            const result = getAdjustedSubtitle();
            if (result) {
                subtitleText.value = result.content;
                handleSubtitleTextChange();
                alert("æ™‚é–“è»¸èª¿æ•´å·²æ‡‰ç”¨åˆ°ä¸Šæ–¹å­—å¹•æ¡†ã€‚");
                scrollToElement(subtitleText);
            }
        });
        downloadDirectAdjustBtn.addEventListener('click', () => {
            const result = getAdjustedSubtitle();
            if (result) {
                const originalFileName = getFileName(subtitleFile, 'subtitle.txt');
                const baseName = originalFileName.substring(0, originalFileName.lastIndexOf('.'));
                const extension = originalFileName.substring(originalFileName.lastIndexOf('.'));
                downloadFile(result.content, `${baseName}_adjusted${extension}`, 'text/plain;charset=utf-8');
            }
        });

        calculateSyncBtn.addEventListener('click', () => { const timePattern = /^\d{2}:\d{2}:\d{2},\d{3}$/; const inputs = [originalStartInput, originalEndInput, targetStartInput, targetEndInput]; if (inputs.some(input => !timePattern.test(input.value.trim()))) { alert('è«‹è¼¸å…¥æ­£ç¢ºçš„æ™‚é–“æ ¼å¼ (HH:MM:SS,ms)'); return; } const oStart = timeToMs(originalStartInput.value); const oEnd = timeToMs(originalEndInput.value); const tStart = timeToMs(targetStartInput.value); const tEnd = timeToMs(targetEndInput.value); const oDuration = oEnd - oStart; const tDuration = tEnd - tStart; if (oDuration <= 0 || tDuration <= 0) { alert('èµ·å§‹å’ŒçµæŸæ™‚é–“å¿…é ˆå½¢æˆä¸€å€‹æ­£æ•¸æ™‚é–“æ®µã€‚'); return; } const timeShift = tStart - (oStart * tDuration / oDuration); const speedFactor = oDuration / tDuration; lastCalculatedParams = { timeShift, speedFactor }; syncInfoPanel.innerHTML = `<b>è¨ˆç®—çµæœ:</b><br>- æ™‚é–“åç§»: ${msToTime(timeShift, true)}<br>- åŸå§‹æŒçºŒæ™‚é–“: ${msToTime(oDuration)}<br>- ç›®æ¨™æŒçºŒæ™‚é–“: ${msToTime(tDuration)}<br><div class="input-group" style="margin-top:10px;"><label for="speedFactorSync">é€Ÿç‡å› å­ (å¯æ‰‹å‹•ä¿®æ”¹):</label><input type="number" id="speedFactorSync" value="${speedFactor.toFixed(6)}" step="0.000001"></div>`; applyAnchorSyncBtn.disabled = false; downloadAnchorSyncBtn.disabled = false; });
        
        function getSyncedSubtitle() {
            const speedFactorSyncInput = document.getElementById('speedFactorSync');
            if (!lastCalculatedParams || !speedFactorSyncInput) { alert("è«‹å…ˆè¨ˆç®—åŒæ­¥åƒæ•¸ã€‚"); return null; }
            const parsedData = currentParsedSubs;
            if (parsedData.length === 0) { alert("ç„¡æ³•è§£æä¸Šæ–¹å­—å¹•å…§å®¹ã€‚"); return null; }
            const finalSpeedFactor = parseFloat(speedFactorSyncInput.value);
            const adjustedData = adjustSubtitleTime(parsedData, lastCalculatedParams.timeShift, finalSpeedFactor);
            if(adjustedData) return { content: rebuildSubtitle(adjustedData) };
            return null;
        }
        applyAnchorSyncBtn.addEventListener('click', () => {
            const result = getSyncedSubtitle();
            if (result) {
                subtitleText.value = result.content;
                handleSubtitleTextChange();
                alert("éŒ¨é»åŒæ­¥å·²æ‡‰ç”¨åˆ°ä¸Šæ–¹å­—å¹•æ¡†ã€‚");
                scrollToElement(subtitleText);
            }
        });
        downloadAnchorSyncBtn.addEventListener('click', () => {
             const result = getSyncedSubtitle();
            if (result) {
                const originalFileName = getFileName(subtitleFile, 'subtitle.txt');
                const baseName = originalFileName.substring(0, originalFileName.lastIndexOf('.'));
                const extension = originalFileName.substring(originalFileName.lastIndexOf('.'));
                downloadFile(result.content, `${baseName}_synced${extension}`, 'text/plain;charset=utf-8');
            }
        });
        
        function getCutSubtitle() {
            const parsedData = currentParsedSubs;
            if (parsedData.length === 0) { alert("ç„¡æ³•è§£æä¸Šæ–¹å­—å¹•å…§å®¹ã€‚"); return null; }
            const startLine = parseInt(cutStartLineInput.value, 10);
            const endLine = parseInt(cutEndLineInput.value, 10);
            if (isNaN(startLine) || isNaN(endLine) || startLine < 1 || startLine > endLine || endLine > parsedData.length) { alert("è«‹è¼¸å…¥æœ‰æ•ˆçš„èµ·å§‹å’ŒçµæŸè¡Œè™Ÿã€‚"); return null; }
            const cutData = parsedData.slice(startLine - 1, endLine);
            if (cutData.length === 0) { alert("åœ¨æŒ‡å®šçš„è¡Œè™Ÿç¯„åœå…§æœªæ‰¾åˆ°ä»»ä½•å­—å¹•ã€‚"); return null; }
            const firstItem = cutData[0];
            const timeOffsetMs = -timeToMs((firstItem.originalFormat === 'formatSrt') ? firstItem.start : vttLikeTimeToSrt(firstItem.start));
            const shiftedData = cutData.map((item, index) => {
                const newItem = JSON.parse(JSON.stringify(item));
                const timeParser = (ts, format) => (format === 'formatSrt' ? timeToMs(ts) : timeToMs(vttLikeTimeToSrt(ts)));
                let startMs = timeParser(newItem.start, newItem.originalFormat) + timeOffsetMs;
                let endMs = timeParser(newItem.end, newItem.originalFormat) + timeOffsetMs;
                startMs = Math.max(0, startMs); endMs = Math.max(0, endMs);
                let newStartStr = msToTime(startMs); let newEndStr = msToTime(endMs);
                if (newItem.originalFormat === 'formatVttLike') { newStartStr = srtTimeToVttLike(newStartStr); newEndStr = srtTimeToVttLike(newEndStr); }
                newItem.start = newStartStr; newItem.end = newEndStr;
                newItem.index = index + 1;
                return newItem;
            });
            return { content: rebuildSubtitle(shiftedData), count: shiftedData.length, startLine, endLine };
        }
        applyCutBtn.addEventListener('click', () => {
            const result = getCutSubtitle();
            if (result) {
                subtitleText.value = result.content;
                handleSubtitleTextChange();
                alert(`å­—å¹•å·²å¾ç¬¬ ${result.startLine} è¡Œåˆ‡å‰²è‡³ç¬¬ ${result.endLine} è¡Œï¼Œä¸¦é‡ç½®æ™‚é–“è»¸ã€‚ä¿ç•™äº† ${result.count} æ¢å­—å¹•ã€‚`);
                scrollToElement(subtitleText);
            }
        });
        downloadCutBtn.addEventListener('click', () => {
            const result = getCutSubtitle();
            if(result) {
                const originalFileName = getFileName(subtitleFile, 'subtitle.txt');
                const baseName = originalFileName.substring(0, originalFileName.lastIndexOf('.'));
                const extension = originalFileName.substring(originalFileName.lastIndexOf('.'));
                const newFileName = `${baseName}_cut_${result.startLine}-${result.endLine}${extension}`;
                downloadFile(result.content, newFileName, 'text/plain;charset=utf-8');
            }
        });
        cutStartLineInput.addEventListener('input', () => { isUpdatingCutFields = true; const line = parseInt(cutStartLineInput.value, 10); const parsedData = currentParsedSubs; if (!isNaN(line) && line > 0 && line <= parsedData.length) { const item = parsedData[line - 1]; cutStartInput.value = (item.originalFormat === 'formatSrt') ? item.start : vttLikeTimeToSrt(item.start); } isUpdatingCutFields = false; });
        cutEndLineInput.addEventListener('input', () => { isUpdatingCutFields = true; const line = parseInt(cutEndLineInput.value, 10); const parsedData = currentParsedSubs; if (!isNaN(line) && line > 0 && line <= parsedData.length) { const item = parsedData[line - 1]; cutEndInput.value = (item.originalFormat === 'formatSrt') ? item.end : vttLikeTimeToSrt(item.end); } isUpdatingCutFields = false; });
        cutStartInput.addEventListener('input', () => { isUpdatingCutFields = true; const timeMs = parseFlexibleTimestamp(cutStartInput.value); const parsedData = currentParsedSubs; if (!isNaN(timeMs) && parsedData.length > 0) { const timeParser = (ts, format) => (format === 'formatSrt' ? timeToMs(ts) : timeToMs(vttLikeTimeToSrt(ts))); const index = parsedData.findIndex(item => timeParser(item.start, item.originalFormat) >= timeMs); cutStartLineInput.value = (index === -1) ? parsedData.length : index + 1; } isUpdatingCutFields = false; });
        cutEndInput.addEventListener('input', () => { isUpdatingCutFields = true; const timeMs = parseFlexibleTimestamp(cutEndInput.value); const parsedData = currentParsedSubs; if (!isNaN(timeMs) && parsedData.length > 0) { const timeParser = (ts, format) => (format === 'formatSrt' ? timeToMs(ts) : timeToMs(vttLikeTimeToSrt(ts))); const index = parsedData.findIndex(item => timeParser(item.end, item.originalFormat) >= timeMs); cutEndLineInput.value = (index === -1) ? parsedData.length : index + 1; } isUpdatingCutFields = false; });
        
        function getMergedSubtitle() {
            const subText1 = mergeFile1Content.value.trim();
            const subText2 = mergeFile2Content.value.trim();
            if (!subText1) { alert('æª”æ¡ˆ1ä¸­æ²’æœ‰å…§å®¹å¯ä¾›åˆä½µã€‚'); return null; }
            if (!subText2) {
                const parsedData1 = parseSubtitle(subText1);
                 if (parsedData1.length === 0) { alert('ç„¡æ³•è§£ææª”æ¡ˆ1çš„å­—å¹•æ ¼å¼ã€‚'); return null; }
                return { content: rebuildSubtitle(parsedData1), count: parsedData1.length };
            }
            const parsedData1 = parseSubtitle(subText1);
            const parsedData2 = parseSubtitle(subText2);
            if (parsedData1.length === 0) { alert('ç„¡æ³•è§£ææª”æ¡ˆ1çš„å­—å¹•æ ¼å¼ã€‚'); return null; }
            if (parsedData2.length === 0) { alert('ç„¡æ³•è§£ææª”æ¡ˆ2çš„å­—å¹•æ ¼å¼ã€‚'); return null; }
            const lastItem1 = parsedData1[parsedData1.length - 1];
            const lastEndTimeSrt = lastItem1.originalFormat === 'formatSrt' ? lastItem1.end : vttLikeTimeToSrt(lastItem1.end);
            const offsetMs = timeToMs(lastEndTimeSrt);
            if (offsetMs < 0) { alert('æª”æ¡ˆ1çš„çµæŸæ™‚é–“ç„¡æ•ˆã€‚'); return null; }
            const timeParser = (ts, format) => (format === 'formatSrt' ? timeToMs(ts) : timeToMs(vttLikeTimeToSrt(ts)));
            const shiftedData2 = parsedData2.map(item => {
                const newItem = JSON.parse(JSON.stringify(item));
                let startMs = timeParser(item.start, item.originalFormat) + offsetMs;
                let endMs = timeParser(item.end, item.originalFormat) + offsetMs;
                let newStartStr = msToTime(startMs); let newEndStr = msToTime(endMs);
                if (newItem.originalFormat === 'formatVttLike') { newStartStr = srtTimeToVttLike(newStartStr); newEndStr = srtTimeToVttLike(newEndStr); }
                newItem.start = newStartStr; newItem.end = newEndStr;
                return newItem;
            });
            const combinedData = [...parsedData1, ...shiftedData2].map((item, index) => {
                item.index = index + 1; 
                item.targetFormat = parsedData1[0].originalFormat;
                if (item.targetFormat === 'formatSrt') { if (item.originalFormat === 'formatVttLike') { item.start = vttLikeTimeToSrt(item.start); item.end = vttLikeTimeToSrt(item.end); } } 
                else { if (item.originalFormat === 'formatSrt') { item.start = srtTimeToVttLike(item.start); item.end = srtTimeToVttLike(item.end); } }
                return item;
            });
            return { content: rebuildSubtitle(combinedData), count: combinedData.length };
        }
        mergeSubtitlesBtn.addEventListener('click', () => {
             const result = getMergedSubtitle();
             if (result) {
                subtitleText.value = result.content;
                handleSubtitleTextChange();
                alert(`å­—å¹•åˆä½µæˆåŠŸï¼å…± ${result.count} æ¢å­—å¹•ï¼Œçµæœå·²æ›´æ–°è‡³ä¸Šæ–¹ä¸»å­—å¹•æ¡†ã€‚`);
                scrollToElement(subtitleText);
             }
        });

        downloadMergedBtn.addEventListener('click', () => {
            const subText1 = mergeFile1Content.value;
            const subText2 = mergeFile2Content.value;
            const originalFileName = getFileName(mergeFile1Input, 'subtitle1.txt');
            const baseName = originalFileName.substring(0, originalFileName.lastIndexOf('.'));
            const extension = originalFileName.substring(originalFileName.lastIndexOf('.'));

            if (subText1.trim() && !subText2.trim()) {
                downloadFile(subText1, `${baseName}_merged${extension}`, 'text/plain;charset=utf-8');
                alert('å·²ä¸‹è¼‰æª”æ¡ˆ1å€åŸŸä¸­çš„å…§å®¹ã€‚');
            } else if (subText1.trim() && subText2.trim()) {
                const result = getMergedSubtitle();
                if (result) {
                    downloadFile(result.content, `${baseName}_merged${extension}`, 'text/plain;charset=utf-8');
                }
            } else {
                alert('æ²’æœ‰å¯ä¾›ä¸‹è¼‰çš„åˆä½µå­—å¹•å…§å®¹ã€‚è«‹å…ˆè¼‰å…¥æª”æ¡ˆã€‚');
            }
        });

        addAndMergeBtn.addEventListener('click', () => {
            const result = getMergedSubtitle();
            if (result) {
                mergeFile1Content.value = result.content;
                mergeFile1Input.value = '';
                mergeFile2Content.value = '';
                mergeFile2Input.value = '';
                toggleAddMergeButton(); 
                alert(`é™„åŠ æˆåŠŸï¼ç›®å‰æª”æ¡ˆ1ä¸­åŒ…å« ${result.count} æ¢å­—å¹•ã€‚è«‹é¸æ“‡ä¸‹ä¸€å€‹è¦é™„åŠ çš„æª”æ¡ˆã€‚`);
            }
        });
        function toggleAddMergeButton() {
            const hasText1 = mergeFile1Content.value.trim().length > 0;
            const hasText2 = mergeFile2Content.value.trim().length > 0;
            addAndMergeBtn.style.display = (hasText1 && hasText2) ? 'inline-block' : 'none';
        }
        mergeFile1Input.addEventListener('change', () => readFile(mergeFile1Input.files[0], mergeFile1Content, toggleAddMergeButton));
        mergeFile2Input.addEventListener('change', () => readFile(mergeFile2Input.files[0], mergeFile2Content, toggleAddMergeButton));
        mergeFile1Content.addEventListener('input', toggleAddMergeButton);
        mergeFile2Content.addEventListener('input', toggleAddMergeButton);
        
        function srtTimeToVttLike(timeStr) { const [hms, ms] = timeStr.split(','); const [h, m, s] = hms.split(':').map(Number); const totalMinutes = h * 60 + m; return `${String(totalMinutes).padStart(2, '0')}:${String(s).padStart(2, '0')}.${ms}`; }
        function vttLikeTimeToSrt(timeStr) { if(!timeStr) return "00:00:00,000"; const [main, ms] = timeStr.replace(',', '.').split('.'); const parts = main.split(':').map(Number); let h = 0, m = 0, s = 0; if (parts.length === 3) { [h, m, s] = parts; } else if (parts.length === 2) { const totalMinutes = parts[0]; h = Math.floor(totalMinutes / 60); m = totalMinutes % 60; s = parts[1]; } const pad = (num) => String(num).padStart(2, '0'); return `${pad(h)}:${pad(m)}:${pad(s)},${(ms || '0').padEnd(3, '0')}`; }
        convertSubtitleFormatButton.addEventListener('click', () => { const currentText = subtitleText.value; const format = detectSubtitleFormat(currentText); if (format === 'unknown') { alert('ç„¡æ³•è­˜åˆ¥çš„å­—å¹•æ ¼å¼ï¼Œç„¡æ³•è½‰æ›ã€‚'); return; } const parsedData = parseSubtitle(currentText); if (format === 'formatSrt') { parsedData.forEach(item => { item.start = srtTimeToVttLike(item.start); item.end = srtTimeToVttLike(item.end); item.targetFormat = 'formatVttLike'; }); } else { parsedData.forEach(item => { item.start = vttLikeTimeToSrt(item.start); item.end = vttLikeTimeToSrt(item.end); item.targetFormat = 'formatSrt'; }); } subtitleText.value = rebuildSubtitle(parsedData); downloadConvertedButton.style.display = 'inline-block'; handleSubtitleTextChange(); alert('æ ¼å¼è½‰æ›æˆåŠŸï¼'); });
        downloadConvertedButton.addEventListener('click', () => { const format = detectSubtitleFormat(subtitleText.value); const extension = format === 'formatSrt' ? '.srt' : '.vtt'; downloadFile(subtitleText.value, `converted${extension}`, 'text/plain;charset=utf-8'); });
        
        function convertOldToNewFormat(text) { const { map } = parseOldCorrectionFormat(text, false); const newFormatLines = []; for (const original in map) { newFormatLines.push(`-<${original}[${map[original] === null ? '' : map[original]}]>`); } return newFormatLines.join('\n'); }
        function convertNewToOldFormat(text) { const { map } = parseNewCorrectionFormat(text, false); const oldFormatLines = []; for (const original in map) { const rule = map[original]; let correctedText; if (rule.replacement === null) { correctedText = '(ä¿ç•™åŸæ¨£)'; } else { correctedText = rule.replacement; } oldFormatLines.push(`- åŸå§‹å­—å¹•å…§å®¹ï¼š${original}`); oldFormatLines.push(`- å»ºè­°ä¿®æ­£å…§å®¹ï¼š${correctedText}`); } return oldFormatLines.join('\n'); }
        convertCorrectionFormatButton.addEventListener('click', () => { const currentText = correctionText.value; const format = detectCorrectionFormat(currentText); let resultText = ''; if (format === 'old') { resultText = convertOldToNewFormat(currentText); if (resultText) { correctionText.value = resultText; alert('å·²å°‡ä¿®æ­£æª”è½‰ç‚ºæ–°æ ¼å¼ï¼'); } else { alert('æœªæ‰¾åˆ°å¯è½‰æ›çš„èˆŠæ ¼å¼å…§å®¹ã€‚'); } } else if (format === 'new') { resultText = convertNewToOldFormat(currentText); if (resultText) { correctionText.value = resultText; alert('å·²å°‡ä¿®æ­£æª”è½‰ç‚ºèˆŠæ ¼å¼ï¼'); } else { alert('æœªæ‰¾åˆ°å¯è½‰æ›çš„æ–°æ ¼å¼å…§å®¹ã€‚'); } } toggleCorrectionButtons(); });
        compareAndGenerateButton.addEventListener('click', () => { const originalSubText = subtitleText.value; if (!originalSubText.trim()) { alert('è«‹å…ˆåœ¨ä¸»å­—å¹•æ¡†ä¸­æä¾›åŸå§‹å­—å¹•ã€‚'); return; } const fileInput = document.createElement('input'); fileInput.type = 'file'; fileInput.accept = '.txt,.srt,.vtt'; fileInput.onchange = e => { const file = e.target.files[0]; if (!file) return; const reader = new FileReader(); reader.onload = event => { const correctedSubText = event.target.result; generateCorrectionRules(originalSubText, correctedSubText); }; reader.readAsText(file, 'UTF-8'); }; fileInput.click(); });
        function findBestDiff(originalLine, correctedLine) { let start = 0; while (start < originalLine.length && start < correctedLine.length && originalLine[start] === correctedLine[start]) { start++; } let oldEnd = originalLine.length; let newEnd = correctedLine.length; while (oldEnd > start && newEnd > start && originalLine[oldEnd - 1] === correctedLine[newEnd - 1]) { oldEnd--; newEnd--; } const originalDiff = originalLine.substring(start, oldEnd); const correctedDiff = correctedLine.substring(start, newEnd); const CONTEXT_LENGTH = 1; if (originalDiff.length > 0 && originalDiff.length <= CONTEXT_LENGTH) { const expandedStart = Math.max(0, start - CONTEXT_LENGTH); const expandedOldEnd = Math.min(originalLine.length, oldEnd + CONTEXT_LENGTH); const expandedNewEnd = Math.min(correctedLine.length, newEnd + CONTEXT_LENGTH); const finalOriginal = originalLine.substring(expandedStart, expandedOldEnd); const finalCorrected = correctedLine.substring(expandedStart, expandedNewEnd); if (finalOriginal !== finalCorrected) { return { original: finalOriginal, corrected: finalCorrected }; } } return { original: originalDiff, corrected: correctedDiff }; }
        function generateCorrectionRules(originalSubText, correctedSubText) { const originalParsed = parseSubtitle(originalSubText); const correctedParsed = parseSubtitle(correctedSubText); if (originalParsed.length === 0 || correctedParsed.length === 0) { alert('ç„¡æ³•è§£æä¸€å€‹æˆ–å…©å€‹å­—å¹•æª”ï¼Œè«‹æª¢æŸ¥æ ¼å¼ã€‚'); return; } if (originalParsed.length !== correctedParsed.length) { alert(`å­—å¹•è¡Œæ•¸ä¸åŒ¹é… (åŸå§‹: ${originalParsed.length}, ä¿®æ­£å¾Œ: ${correctedParsed.length})ã€‚\né€™å¯èƒ½å°è‡´æ¯”å°ä¸æº–ç¢ºï¼Œä½†ä»æœƒå˜—è©¦æ¯”å°æ™‚é–“ç¢¼ç›¸åŒçš„è¡Œã€‚`); } const rules = new Map(); const correctedMap = new Map(correctedParsed.map(item => [item.start, item])); for (const originalItem of originalParsed) { const correctedItem = correctedMap.get(originalItem.start); const originalText = originalItem.text.trim(); if (correctedItem && originalText !== correctedItem.text.trim()) { const correctedText = correctedItem.text.trim(); const diff = findBestDiff(originalText, correctedText); if (diff.original && diff.original !== diff.corrected) { rules.set(diff.original, diff.corrected); } } } const outputLines = Array.from(rules.entries()).map(([original, corrected]) => `-<${original}[${corrected}]>`); if (outputLines.length > 0) { correctionText.value = outputLines.join('\n'); toggleCorrectionButtons(); alert(`æ¯”å°å®Œæˆï¼å…±ç”Ÿæˆ ${outputLines.length} æ¢ä¿®æ­£è¦å‰‡ã€‚`); scrollToElement(correctionText); } else { alert('æ¯”å°å®Œæˆï¼Œæœªç™¼ç¾ä»»ä½•æ–‡æœ¬å·®ç•°ã€‚'); correctionText.value = ''; toggleCorrectionButtons(); } }
        
        toggleFixerModeBtn.addEventListener('click', () => {
            const isActive = document.body.classList.toggle('fixer-mode-active');
            if (isActive) {
                toggleFixerModeBtn.textContent = 'è¿”å›ä¸€èˆ¬æ¨¡å¼';
                cardVideoControls.style.display = 'block'; // Show video controls card
                setPlayerPinned(pinVideoPlayerCheckbox.checked); 
                document.querySelector('.collapsible-section').classList.remove('is-open');
                scrollToElement(document.querySelector('.main-grid'));
            } else {
                toggleFixerModeBtn.textContent = 'é€²å…¥ä¿®æ­£æ¨¡å¼';
                document.body.classList.remove('video-fixer-mode-pinned');
                floatingVideoContainer.style.display = 'none';
                toggleVideoPlayerCheckbox.checked = false;
                pinVideoPlayerCheckbox.checked = false;
                setPlayerPinned(false);
                cardVideoControls.style.display = 'none';
            }
        });

        fixButton.addEventListener('click', () => {
            const subtitle = subtitleText.value;
            const correction = correctionText.value;
            if (!subtitle || !correction) { alert("è«‹æä¾›å­—å¹•å’Œä¿®æ­£æª”å…§å®¹ã€‚"); return; }
            const correctionMap = parseCorrection(correction, removeBrackets.checked);
            if (Object.keys(correctionMap).length === 0) { alert("æœªæ‰¾åˆ°æœ‰æ•ˆçš„ä¿®æ­£è¦å‰‡ã€‚"); return; }
            const parsedData = currentParsedSubs;
            if (parsedData.length === 0) { alert("ç„¡æ³•è§£æå­—å¹•æª”ï¼Œè«‹æª¢æŸ¥å­—å¹•æ ¼å¼ã€‚"); return; }
            const result = applyCorrections(parsedData, correctionMap);
            appliedCorrectionsData = result.appliedCorrections;
            totalCorrectionsCount = result.correctionCount;
            correctedSubtitle = rebuildSubtitle(result.modifiedData);
            outputLog.innerHTML = result.outputLog;
            newlyAddedRules.value = '';

            const summarySpan = document.createElement('span');
            summarySpan.textContent = `ç¸½å…±ä¿®æ­£äº† ${totalCorrectionsCount} è™•å­—å¹•éŒ¯èª¤`;
            const toggleBtn = document.createElement('button');
            toggleBtn.id = 'toggleOptionsBtn';
            toggleBtn.className = 'secondary';
            
            const showRevertOptions = isDefaultShowRevertEnabled;
            toggleBtn.textContent = showRevertOptions ? 'éš±è—ä¿®æ”¹é¸é …' : 'é¡¯ç¤ºä¿®æ”¹é¸é …';
            document.querySelectorAll('.revert-controls').forEach(control => { 
                control.style.display = showRevertOptions ? 'block' : 'none'; 
            });

            toggleBtn.addEventListener('click', (e) => {
                const btn = e.target;
                const revertControls = document.querySelectorAll('.revert-controls');
                if (revertControls.length === 0) return;
                const isHidden = revertControls[0].style.display === 'none';
                revertControls.forEach(control => { control.style.display = isHidden ? 'block' : 'none'; });
                btn.textContent = isHidden ? 'éš±è—ä¿®æ”¹é¸é …' : 'é¡¯ç¤ºä¿®æ”¹é¸é …';
            });

            correctionSummary.innerHTML = ''; 
            
            if (result.correctionCount > 0) {
                correctionSummary.appendChild(summarySpan);
                correctionSummary.appendChild(toggleBtn);
                inlineControlsGroup.style.display = 'inline-flex';
            } else {
                summarySpan.textContent = "æœªç™¼ç¾éœ€è¦ä¿®æ­£çš„å…§å®¹ã€‚";
                correctionSummary.appendChild(summarySpan);
                inlineControlsGroup.style.display = 'none';
            }
            
            hideCancelledRulesToggle.checked = true;
            updateHiddenRules();
        });

        downloadButton.addEventListener('click', () => {
            const originalSubText = subtitleText.value;
            if (!originalSubText) {
                alert("æ²’æœ‰å¯ä¾›ä¸‹è¼‰çš„å­—å¹•å…§å®¹ã€‚");
                return;
            }
        
            const allRules = [];
            const baseCorrectionMap = parseCorrection(correctionText.value, removeBrackets.checked);
            for (const original in baseCorrectionMap) {
                allRules.push({ original, ...baseCorrectionMap[original] });
            }
            const newRulesText = newlyAddedRules.value;
            const newCorrectionMap = newRulesText ? parseNewCorrectionFormat(newRulesText, false).map : {};
            for (const original in newCorrectionMap) {
                allRules.push({ original, ...newCorrectionMap[original] });
            }
            allRules.sort((a, b) => b.original.length - a.original.length);
        
            const globallyRevertedRules = new Set();
            document.querySelectorAll('.revert-rule:checked').forEach(cb => {
                globallyRevertedRules.add(cb.dataset.ruleOriginal.replace(/\\/g, ''));
            });
        
            const instanceRevertedKeys = new Set();
            document.querySelectorAll('.revert-instance:checked').forEach(cb => {
                const original = cb.dataset.ruleOriginal.replace(/\\/g, '');
                const replacement = decodeURIComponent(cb.dataset.ruleReplacement);
                const key = `${cb.dataset.itemIndex}-${original}->${replacement}`;
                instanceRevertedKeys.add(key);
            });
            
            const originalParsedData = currentParsedSubs;
            const finalParsedData = JSON.parse(JSON.stringify(originalParsedData));
            
            finalParsedData.forEach(item => {
                const lineArchived = outputLog.querySelector(`.diff-line[data-item-index-line="${item.index}"]`)?.dataset.archived === 'true';
                if (lineArchived) {
                    return; 
                }
                
                let currentText = item.text;
        
                allRules.forEach(rule => {
                    const original = rule.original;
                    if (globallyRevertedRules.has(original)) return;
                    
                    const specificInstanceKey = `${item.index}-${original}->${rule.replacement}`;
                    if (instanceRevertedKeys.has(specificInstanceKey)) return;
        
                    if (!rule || rule.replacement === null) return;
                    
                    const itemIndexInt = parseInt(item.index, 10);
                    if (rule.lineNumbers && rule.lineNumbers.length > 0 && !rule.lineNumbers.includes(itemIndexInt)) {
                        return; 
                    }
        
                    let tempText = currentText;
                    const placeholders = {};
                    let placeholderIndex = 0;
                    if (rule.exclusions && rule.exclusions.length > 0) {
                        const sortedExclusions = [...rule.exclusions].sort((a,b) => b.length - a.length);
                        sortedExclusions.forEach(excl => {
                            if (!excl.includes(original)) return;
                            tempText = tempText.replace(new RegExp(escapeRegExp(excl), 'g'), match => {
                                const placeholder = `__DL_PH_${placeholderIndex++}__`;
                                placeholders[placeholder] = match;
                                return placeholder;
                            });
                        });
                    }
        
                    const replacementString = rule.replacement;
                    const tempTextAfterReplace = tempText.replace(new RegExp(escapeRegExp(original), 'g'), replacementString);
                    
                    if (tempText !== tempTextAfterReplace) {
                        tempText = tempTextAfterReplace;
                        for (const placeholder in placeholders) {
                            tempText = tempText.replace(new RegExp(escapeRegExp(placeholder), 'g'), placeholders[placeholder]);
                        }
                        currentText = tempText;
                    }
                });
                item.text = currentText;
            });
        
            const finalSubtitleContent = rebuildSubtitle(finalParsedData);
            const originalFileName = getFileName(subtitleFile, 'subtitle.txt');
            const baseName = originalFileName.substring(0, originalFileName.lastIndexOf('.'));
            const extension = originalFileName.substring(originalFileName.lastIndexOf('.'));
            downloadFile(finalSubtitleContent, `${baseName}_corrected_final${extension}`, 'text/plain;charset=utf-8');
        });
        
        downloadRulesButton.addEventListener('click', () => {
            if (Object.keys(appliedCorrectionsData).length === 0 && !newlyAddedRules.value.trim()) {
                alert("è«‹å…ˆåŸ·è¡Œã€Œä¿®æ­£å­—å¹•ã€æˆ–ã€Œæ–°å¢è¦å‰‡ã€å¾Œå†ä¸‹è¼‰æœ€çµ‚ä¿®æ­£è©ã€‚");
                return;
            }
        
            const finalRulesContent = [];
            const consolidatedRules = new Map();
        
            const addRuleToConsolidate = (original, replacement, lineNumbers, exclusions = []) => {
                const replacementKey = replacement === null ? '___NULL___' : replacement;
                if (!consolidatedRules.has(original)) {
                    consolidatedRules.set(original, new Map());
                }
                const replacementMap = consolidatedRules.get(original);
                if (!replacementMap.has(replacementKey)) {
                    replacementMap.set(replacementKey, { lineNumbers: new Set(), exclusions: new Set(exclusions) });
                }
                const ruleData = replacementMap.get(replacementKey);
                lineNumbers.forEach(ln => ruleData.lineNumbers.add(ln));
                exclusions.forEach(ex => ruleData.exclusions.add(ex));
            };
        
            const initialCorrectionMap = parseCorrection(correctionText.value, removeBrackets.checked);
            const manualRulesMap = newlyAddedRules.value.trim() ? parseNewCorrectionFormat(newlyAddedRules.value, false).map : {};
            
            document.querySelectorAll('.diff-line').forEach(line => {
                const itemIndex = parseInt(line.dataset.itemIndexLine, 10);
                const lineData = appliedCorrectionsData[itemIndex];
                if (!lineData) return;
        
                const isArchived = line.dataset.archived === 'true';
        
                for (const ruleApplied of lineData.rulesApplied) {
                    const original = ruleApplied.from;
        
                    const instanceRevertCheckbox = line.querySelector(`.revert-instance[data-item-index="${itemIndex}"][data-rule-original="${escapeRegExp(original)}"]`);
                    const isInstanceCancelled = instanceRevertCheckbox ? instanceRevertCheckbox.checked : false;
        
                    const globalRevertCheckbox = document.querySelector(`.revert-rule[data-rule-original="${escapeRegExp(original)}"]`);
                    const isGloballyCancelled = globalRevertCheckbox ? globalRevertCheckbox.checked : false;
        
                    if (isArchived || (!isInstanceCancelled && !isGloballyCancelled)) {
                        const exclusions = initialCorrectionMap[original]?.exclusions || [];
                        addRuleToConsolidate(original, ruleApplied.to, [itemIndex], exclusions);
                    }
                }
            });
            
            for (const original in manualRulesMap) {
                const rule = manualRulesMap[original];
                addRuleToConsolidate(original, rule.replacement, rule.lineNumbers, rule.exclusions);
            }
        
            for (const [original, replacementMap] of consolidatedRules.entries()) {
                for (const [replacementKey, data] of replacementMap.entries()) {
                    const exclusionStr = Array.from(data.exclusions).join(',');
                    const linesStr = Array.from(data.lineNumbers).sort((a, b) => a - b).join(',');
                    const replacementStr = replacementKey === '___NULL___' ? '' : replacementKey;
                    
                    let ruleString = `-<${original}[${replacementStr}]`;
                    if (exclusionStr || linesStr) {
                         ruleString += `|${exclusionStr}|${linesStr}`;
                    }
                    ruleString += '>';
                    finalRulesContent.push(ruleString);
                }
            }
        
            if (finalRulesContent.length === 0) {
                alert("æ²’æœ‰å¯ä¾›ä¸‹è¼‰çš„æœ‰æ•ˆä¿®æ­£è© (æ‰€æœ‰ä¿®æ­£å¯èƒ½éƒ½å·²è¢«å–æ¶ˆæˆ–ç„¡æ–°å¢)ã€‚");
                return;
            }
        
            downloadFile(finalRulesContent.join('\n'), 'final_corrections.txt', 'text/plain;charset=utf-8');
        });

        function detectSubtitleFormat(text) { const lines = text.trim().split('\n').filter(Boolean); if (lines.length === 0) return 'unknown'; if (lines[0].trim().startsWith('[') && lines[0].includes('-->')) return 'formatVttLike'; const srtRegex = /^\d{2}:\d{2}:\d{2},\d{3} --> \d{2}:\d{2}:\d{2},\d{3}$/; if (/^\d+$/.test(lines[0]) && lines[1] && srtRegex.test(lines[1].trim())) return 'formatSrt'; return 'unknown'; }
        function parseSubtitle(text) { const format = detectSubtitleFormat(text); const parsed = []; if (format === 'formatSrt') { text.trim().split(/\n\s*\n/).forEach(block => { const lines = block.split('\n'); const timeMatch = lines[1]?.match(/(\d{2}:\d{2}:\d{2},\d{3}) --> (\d{2}:\d{2}:\d{2},\d{3})/); if (lines[0]?.match(/^\d+$/) && timeMatch) { parsed.push({ index: lines[0], start: timeMatch[1], end: timeMatch[2], text: lines.slice(2).join('\n'), originalFormat: 'formatSrt' }); } }); } else if (format === 'formatVttLike') { const lineRegex = /\[(.*?) --> (.*?)\]\s*(.*)/s; text.trim().split('\n').forEach((line, index) => { const match = line.match(lineRegex); if(match) { parsed.push({ index: index + 1, start: match[1].trim(), end: match[2].trim(), text: match[3].trim(), originalFormat: 'formatVttLike' }); } }); } return parsed; };
        function rebuildSubtitle(parsedData) { if (!parsedData || parsedData.length === 0) return ""; const formatToBuild = parsedData[0].targetFormat || parsedData[0].originalFormat; const blocks = parsedData.map(item => { if(formatToBuild === 'formatSrt') { return `${item.index}\n${item.start} --> ${item.end}\n${item.text}`; } else { return `[${item.start} --> ${item.end}] ${item.text}`; } }); const separator = formatToBuild === 'formatSrt' ? '\n\n' : '\n'; return blocks.join(separator); };
        function parseOldCorrectionFormat(text, shouldRemoveBrackets) { const corrections = {}; const lines = text.split('\n').filter(Boolean); const originalPrefix = '- åŸå§‹å­—å¹•å…§å®¹ï¼š'; const correctedPrefix = '- å»ºè­°ä¿®æ­£å…§å®¹ï¼š'; for (let i = 0; i < lines.length - 1; i++) { if (lines[i].startsWith(originalPrefix) && lines[i + 1].startsWith(correctedPrefix)) { const originalText = lines[i].substring(originalPrefix.length).trim(); let correctedText = lines[i + 1].substring(correctedPrefix.length).trim(); if (correctedText === "(ä¿ç•™åŸæ¨£)") { correctedText = null; } else if (shouldRemoveBrackets) { correctedText = correctedText.replace(/ï¼ˆ[^ï¼‰]*ï¼‰/g, '').replace(/\([^\)]*\)/g, '').trim(); } originalText.split(',').map(o => o.trim()).filter(Boolean).forEach(o => { corrections[o] = correctedText; }); i++; } } return { map: corrections }; };
        
        function parseNewCorrectionFormat(text, shouldRemoveBrackets) {
            const corrections = {};
            const ruleRegex = /-<(.*?)\[(.*?)\](?:\|(.*))?>/s;
            const lineNumRegex = /^[\d\s,]*$/;

            text.split('\n').forEach(line => {
                const match = line.trim().match(ruleRegex);
                if (match) {
                    const original = match[1].trim();
                    let corrected = match[2].trim();
                    const extras = match[3] || '';

                    if (shouldRemoveBrackets) {
                        corrected = corrected.replace(/ï¼ˆ[^ï¼‰]*ï¼‰/g, '').replace(/\([^\)]*\)/g, '').trim();
                    }

                    if (original) {
                        const parts = extras.split('|').map(p => p.trim());
                        let exclusionsStr = '';
                        let lineNumbersStr = '';

                        if (parts.length === 2) {
                            exclusionsStr = parts[0];
                            lineNumbersStr = parts[1];
                        } else if (parts.length === 1 && parts[0]) {
                            if (lineNumRegex.test(parts[0])) {
                                lineNumbersStr = parts[0];
                            } else {
                                exclusionsStr = parts[0];
                            }
                        }

                        const exclusions = exclusionsStr ? exclusionsStr.split(',').map(e => e.trim()).filter(Boolean) : [];
                        const lineNumbers = lineNumbersStr ? lineNumbersStr.split(',').map(n => parseInt(n.trim(), 10)).filter(n => !isNaN(n)) : [];

                        corrections[original] = {
                            replacement: corrected === '' ? null : corrected,
                            exclusions: exclusions,
                            lineNumbers: lineNumbers
                        };
                    }
                }
            });
            return { map: corrections };
        };

        function parseCorrection(text, shouldRemoveBrackets) {
            const newMap = parseNewCorrectionFormat(text, shouldRemoveBrackets).map;
            if (Object.keys(newMap).length > 0) return newMap;
            const oldMap = parseOldCorrectionFormat(text, shouldRemoveBrackets).map;
            const compatibleMap = {};
            for (const key in oldMap) {
                compatibleMap[key] = { replacement: oldMap[key], exclusions: [], lineNumbers: [] };
            }
            return compatibleMap;
        };
        
        function applyCorrections(parsedData, correctionMap) {
            let outputLogHTML = '';
            let correctionCount = 0;
            const modifiedData = JSON.parse(JSON.stringify(parsedData));
            const appliedCorrections = {}; 
            const correctionKeys = Object.keys(correctionMap).sort((a, b) => b.length - a.length);
            const ruleTotalCounts = {};
            const ruleCurrentCounts = {};

            const shadowParsedData = parsedData.map(item => item.text); 

            correctionKeys.forEach(original => {
                const rule = correctionMap[original];
                if (!rule || rule.replacement === null) {
                    ruleTotalCounts[original] = 0;
                    return;
                }

                let totalMatches = 0;
                shadowParsedData.forEach((lineText, index) => {
                    const itemIndexInt = parseInt(parsedData[index].index, 10);
                    
                    if (rule.lineNumbers && rule.lineNumbers.length > 0 && !rule.lineNumbers.includes(itemIndexInt)) {
                        return;
                    }
                    
                    let countableText = lineText;

                    if (rule.exclusions && rule.exclusions.length > 0) {
                        rule.exclusions.forEach(excl => {
                            countableText = countableText.replace(new RegExp(escapeRegExp(excl), 'g'), (match) => ' '.repeat(match.length));
                        });
                    }

                    const matches = countableText.match(new RegExp(escapeRegExp(original), 'g'));
                    if (matches) {
                        totalMatches += matches.length;
                        shadowParsedData[index] = countableText.replace(new RegExp(escapeRegExp(original), 'g'), (match) => '#'.repeat(match.length));
                    }
                });
                ruleTotalCounts[original] = totalMatches;
            });

            correctionKeys.forEach(key => { ruleCurrentCounts[key] = 0; });
            
            modifiedData.forEach(item => {
                const originalFullText = item.text;
                let currentText = item.text;
                let hasCorrection = false;
                const rulesAppliedOnThisLine = [];
                const itemIndexInt = parseInt(item.index, 10);

                correctionKeys.forEach(original => {
                    const rule = correctionMap[original];
                    if (!rule || rule.replacement === null) return;
                    
                    if (rule.lineNumbers && rule.lineNumbers.length > 0 && !rule.lineNumbers.includes(itemIndexInt)) {
                        return;
                    }

                    let tempText = currentText;
                    const placeholders = {};
                    let placeholderIndex = 0;
                    if (rule.exclusions && rule.exclusions.length > 0) { const sortedExclusions = [...rule.exclusions].sort((a,b) => b.length - a.length); sortedExclusions.forEach(excl => { if (!excl.includes(original)) return; let replacedText = ""; let lastIndex = 0; const regex = new RegExp(escapeRegExp(excl), 'g'); let match; while ((match = regex.exec(tempText)) !== null) { const placeholder = `__SF_PH_${placeholderIndex++}__`; placeholders[placeholder] = excl; replacedText += tempText.substring(lastIndex, match.index) + placeholder; lastIndex = match.index + excl.length; } replacedText += tempText.substring(lastIndex); tempText = replacedText; }); }
                    
                    const replacementString = rule.replacement;
                    const tempTextAfterReplace = tempText.replace(new RegExp(escapeRegExp(original), 'g'), replacementString);
                    
                    if (tempText !== tempTextAfterReplace) {
                        tempText = tempTextAfterReplace; hasCorrection = true;
                        for (const placeholder in placeholders) { tempText = tempText.replace(placeholder, placeholders[placeholder]); }
                        
                        currentText = tempText; 
                        
                        if (!rulesAppliedOnThisLine.find(r => r.from === original)) {
                            const originalMatchesOnThisLine = (originalFullText.match(new RegExp(escapeRegExp(original), 'g')) || []).length;
                            let excludedMatchesOnThisLine = 0;
                            if (rule.exclusions && rule.exclusions.length > 0) { rule.exclusions.forEach(excl => { const originalsInExcl = (excl.match(new RegExp(escapeRegExp(original), 'g')) || []).length; const exclsInLine = (originalFullText.match(new RegExp(escapeRegExp(excl), 'g')) || []).length; excludedMatchesOnThisLine += (originalsInExcl * exclsInLine); }); }
                            const actualMatches = originalMatchesOnThisLine - excludedMatchesOnThisLine;
                            if (actualMatches > 0) { const firstCount = ruleCurrentCounts[original] + 1; const lastCount = ruleCurrentCounts[original] + actualMatches; rulesAppliedOnThisLine.push({ from: original, to: replacementString, firstCount, lastCount, totalCount: ruleTotalCounts[original] }); ruleCurrentCounts[original] += actualMatches; }
                        }
                    }
                });
                
                if (hasCorrection) {
                    correctionCount++; item.text = currentText;
                    const { original: diffOriginal, corrected } = diffStrings(originalFullText, currentText);
                    appliedCorrections[item.index] = { originalText: originalFullText, rulesApplied: rulesAppliedOnThisLine.map(r => ({ from: r.from, to: r.to })) };
                    let countTagsHTML = '';
                    rulesAppliedOnThisLine.forEach(rule => { let countStr = rule.firstCount; if (rule.lastCount > rule.firstCount) countStr += `-${rule.lastCount}`; countTagsHTML += `<span class="count-tag" data-rule-key="${rule.from} -> ${rule.to}"><a class="interactive-rule-tag" href="#" data-rule-from="${rule.from}" data-rule-to="${rule.to}"><span class="from">${rule.from}</span> â†’ <span class="to">${rule.to}</span>: <b class="rule-counts">${countStr}/${rule.totalCount || '?'}</b></a><span class="hidden-count"></span></span>`; });
                    outputLogHTML += `<div class="diff-line" data-item-index-line="${item.index}" data-archived="false">`;
                    outputLogHTML += `<b>ä¿®æ­£å­—å¹•è¡Œ(${item.index}):</b>${countTagsHTML}<br>`;
                    outputLogHTML += `<span class="diff-label">- åŸæ–‡:</span> ${diffOriginal}<br>`;
                    outputLogHTML += `<span class="diff-label">+ ä¿®æ­£:</span> ${corrected}`;
                    outputLogHTML += `<div class="revert-controls" style="display: none;">`;
                    rulesAppliedOnThisLine.forEach(rule => { 
                        outputLogHTML += `<label><input type="checkbox" class="revert-instance" data-item-index="${item.index}" data-rule-original="${escapeRegExp(rule.from)}" data-rule-replacement="${encodeURIComponent(rule.to)}"> å–æ¶ˆæ­¤è¡Œä¿®æ­£: "${rule.from}" â†’ "${rule.to}"</label><br>`; 
                    });
                    outputLogHTML += `<hr style="border:0; border-top: 1px solid #ddd; margin: 5px 0;">`;
                    rulesAppliedOnThisLine.forEach(rule => { outputLogHTML += `<label><input type="checkbox" class="revert-rule" data-rule-original="${escapeRegExp(rule.from)}"> å–æ¶ˆæ‰€æœ‰è¦å‰‡: "${rule.from}" â†’ "${rule.to}"</label>`; });
                    outputLogHTML += `<button class="add-rule-btn secondary">æ–°å¢ä¿®æ­£è¦å‰‡</button>`;
                    outputLogHTML += `</div></div>`;
                }
            });
            return { modifiedData, outputLog: outputLogHTML || "æœªç™¼ç¾éœ€è¦ä¿®æ­£çš„å…§å®¹ã€‚", correctionCount, appliedCorrections };
        }

        function highlightAndScrollToLine(lineNumberStr) {
            if (!lineNumberStr) return;
            
            const subTextContent = subtitleText.value;
            const format = detectSubtitleFormat(subTextContent);
            let start = -1, end = -1;

            if (format === 'formatSrt') {
                const regex = new RegExp(`^${lineNumberStr}\\s*\\n`, 'm');
                const lineMatch = subTextContent.match(regex);
                if (lineMatch) {
                    start = lineMatch.index;
                    let nextBlockStart = subTextContent.indexOf('\n\n', start);
                    end = (nextBlockStart === -1) ? subTextContent.length : nextBlockStart;
                }
            } else if (format === 'formatVttLike') {
                const lines = subTextContent.split('\n');
                const targetLineIndex = parseInt(lineNumberStr, 10) - 1;
                if (targetLineIndex >= 0 && targetLineIndex < lines.length) {
                    start = 0;
                    for (let i = 0; i < targetLineIndex; i++) { start += lines[i].length + 1; }
                    end = start + lines[targetLineIndex].length;
                }
            }

            if (start !== -1) {
                subtitleText.focus({ preventScroll: true });
                subtitleText.setSelectionRange(start, end);
                const targetScrollTop = getScrollTopForSelection(subtitleText, start);
                subtitleText.scrollTop = Math.max(0, targetScrollTop - (subtitleText.clientHeight / 3));
            }
        }
        
        function navigateToSubtitleLine(lineNumberStr) {
            if (!lineNumberStr) return;
            highlightAndScrollToLine(lineNumberStr);
            
            const targetItem = currentParsedSubs.find(item => item.index == lineNumberStr);
            if (targetItem) {
                const startTimeSrt = (targetItem.originalFormat === 'formatSrt') ? targetItem.start : vttLikeTimeToSrt(targetItem.start);
                const startTimeInSeconds = timeToMs(startTimeSrt) / 1000;
                seekAndPlay(startTimeInSeconds);
            }
        }

        function getScrollTopForSelection(textarea, selectionStart) {
            const ruler = document.createElement('div');
            const style = window.getComputedStyle(textarea);
            const css = `position: absolute; visibility: hidden; top: -9999px; left: -9999px; white-space: ${style.whiteSpace}; word-wrap: ${style.wordWrap}; word-break: ${style.wordBreak}; box-sizing: ${style.boxSizing}; border: ${style.border}; font-family: ${style.fontFamily}; font-size: ${style.fontSize}; font-weight: ${style.fontWeight}; font-style: ${style.fontStyle}; letter-spacing: ${style.letterSpacing}; line-height: ${style.lineHeight}; padding: ${style.padding}; width: ${textarea.clientWidth}px;`;
            ruler.style.cssText = css;
            let textBefore = textarea.value.substring(0, selectionStart);
            textBefore = textBefore.replace(/&/g, '&').replace(/</g, '<').replace(/>/g, '>').replace(/\n/g, '<br />');
            ruler.innerHTML = textBefore + '<span id="scroll-marker"></span>';
            document.body.appendChild(ruler);
            const marker = document.getElementById('scroll-marker');
            const scrollTop = marker.offsetTop;
            document.body.removeChild(ruler);
            return scrollTop;
        }

        function updateHiddenRules() {
            if (!hideCancelledRulesToggle.checked) {
                document.querySelectorAll('.diff-line').forEach(line => line.style.display = '');
                document.querySelectorAll('.count-tag .hidden-count').forEach(span => span.innerHTML = '');
                const summarySpan = correctionSummary.querySelector('span');
                if (summarySpan) {
                     summarySpan.innerHTML = `ç¸½å…±ä¿®æ­£äº† ${totalCorrectionsCount} è™•å­—å¹•éŒ¯èª¤`;
                }
                return;
            }

            let totalHiddenInstances = 0;
            const hiddenInstancesByRuleKey = new Map();
            
            document.querySelectorAll('.diff-line').forEach(line => {
                const isLineArchived = line.dataset.archived === 'true';
                line.querySelectorAll('.revert-instance').forEach(instanceCb => {
                    const globalCb = document.querySelector(`.revert-rule[data-rule-original="${instanceCb.dataset.ruleOriginal}"]`);
                    const isGloballyCancelled = globalCb ? globalCb.checked : false;
                    if (isLineArchived || instanceCb.checked || isGloballyCancelled) {
                        totalHiddenInstances++;
                        const ruleKey = `${instanceCb.dataset.ruleOriginal.replace(/\\/g, '')} -> ${decodeURIComponent(instanceCb.dataset.ruleReplacement)}`;
                        hiddenInstancesByRuleKey.set(ruleKey, (hiddenInstancesByRuleKey.get(ruleKey) || 0) + 1);
                    }
                });
            });
            
            document.querySelectorAll('.diff-line').forEach(line => {
                const isLineArchived = line.dataset.archived === 'true';
                if (isLineArchived) {
                    line.style.display = 'none';
                    return;
                }
                
                const instanceCheckboxes = line.querySelectorAll('.revert-instance');
                if (instanceCheckboxes.length === 0) {
                    line.style.display = '';
                    return;
                }

                let allInstancesOnLineHidden = true;
                instanceCheckboxes.forEach(instanceCb => {
                    const globalCb = document.querySelector(`.revert-rule[data-rule-original="${instanceCb.dataset.ruleOriginal}"]`);
                    const isGloballyCancelled = globalCb ? globalCb.checked : false;
                    if (!instanceCb.checked && !isGloballyCancelled) {
                        allInstancesOnLineHidden = false;
                    }
                });

                line.style.display = allInstancesOnLineHidden ? 'none' : '';
            });

            document.querySelectorAll('.count-tag').forEach(tag => {
                const ruleKey = tag.dataset.ruleKey;
                const hiddenCountSpan = tag.querySelector('.hidden-count');
                const hiddenCount = hiddenInstancesByRuleKey.get(ruleKey) || 0;
                if (hiddenCount > 0) {
                    hiddenCountSpan.innerHTML = ` <a href="#" class="show-hidden-rule-link" data-rule-key="${ruleKey}">(éš±è—${hiddenCount})</a>`;
                } else {
                    hiddenCountSpan.innerHTML = '';
                }
            });

            const summarySpan = correctionSummary.querySelector('span');
            let summaryHTML = `ç¸½å…±ä¿®æ­£äº† ${totalCorrectionsCount} è™•å­—å¹•éŒ¯èª¤`;
            if (totalHiddenInstances > 0) {
                summaryHTML += ` <span class="hidden-summary"><a href="#" id="show-hidden-summary-link">(éš±è—${totalHiddenInstances}è™•)</a></span>`;
            }
            if (summarySpan) { summarySpan.innerHTML = summaryHTML; }
        }

        hideCancelledRulesToggle.addEventListener('change', updateHiddenRules);

        function showNewRuleModal(lineNumber = '', prefilledOriginal = '', prefilledReplacement = '') {
            newRuleFormContainer.innerHTML = `
                <div class="new-rule-grid">
                    <label>åŸå§‹å­—å¹•:</label>
                    <div class="input-wrapper">
                         <input type="checkbox" id="modal-get-original-cb" title="è‡ªå‹•å¡«å…¥æ­¤è¡Œè¢«ä¿®æ­£çš„åŸæ–‡">
                         <input type="text" id="modal-rule-original" required>
                    </div>
                </div>
                <div class="new-rule-grid">
                    <label>æ›¿æ›å­—å¹•:</label>
                    <div class="input-wrapper">
                        <input type="checkbox" id="modal-get-replacement-cb" title="è‡ªå‹•å¡«å…¥æ­¤è¡Œçš„ä¿®æ­£å¾Œæ–‡å­—">
                        <input type="text" id="modal-rule-replacement">
                    </div>
                </div>
                <div class="new-rule-grid">
                    <label>é¿å…ä¿®æ­£:</label>
                    <input type="text" id="modal-rule-exclusion" placeholder="è©1,è©2 (ç”¨é€—è™Ÿåˆ†éš”ï¼Œé¸å¡«)">
                </div>
                <div class="new-rule-grid">
                    <label>ä¿®æ­£è¡Œè™Ÿ:</label>
                    <div class="input-wrapper">
                        <input type="checkbox" id="modal-get-line-cb" title="è‡ªå‹•å¡«å…¥ç•¶å‰å­—å¹•è¡Œè™Ÿ">
                        <input type="text" id="modal-rule-lines" placeholder="1,5,12 (ç”¨é€—è™Ÿåˆ†éš”ï¼Œé¸å¡«)">
                    </div>
                </div>`;
            const originalInput = document.getElementById('modal-rule-original');
            const replacementInput = document.getElementById('modal-rule-replacement');
            const linesInput = document.getElementById('modal-rule-lines');
            const getOriginalCb = document.getElementById('modal-get-original-cb');
            const getReplacementCb = document.getElementById('modal-get-replacement-cb');
            const getLineCb = document.getElementById('modal-get-line-cb');

            getOriginalCb.addEventListener('change', () => { originalInput.value = getOriginalCb.checked ? prefilledOriginal : ''; });
            getReplacementCb.addEventListener('change', () => { replacementInput.value = getReplacementCb.checked ? prefilledReplacement : ''; });
            getLineCb.addEventListener('change', () => {
                 if (getLineCb.checked && lineNumber) {
                    const existingLines = linesInput.value.trim().split(',').filter(Boolean).map(n=>parseInt(n));
                    if (!existingLines.includes(parseInt(lineNumber))) {
                        existingLines.push(parseInt(lineNumber));
                        linesInput.value = existingLines.sort((a,b) => a-b).join(',');
                    }
                } else {
                    const existingLines = linesInput.value.trim().split(',').filter(Boolean).map(n=>parseInt(n));
                    const index = existingLines.indexOf(parseInt(lineNumber));
                    if (index > -1) {
                        existingLines.splice(index, 1);
                        linesInput.value = existingLines.sort((a,b) => a-b).join(',');
                    }
                }
            });
            openModal(newRuleModal);
        }

        outputLogContainer.addEventListener('click', function(event) {
            const target = event.target;
            
            if (target.matches('.add-rule-btn')) {
                event.preventDefault();
                const diffLine = target.closest('.diff-line');
                if (!diffLine) return;
                const itemIndex = diffLine.dataset.itemIndexLine;
                const appliedRulesOnLine = appliedCorrectionsData[itemIndex]?.rulesApplied || [];
                const firstRule = appliedRulesOnLine.length > 0 ? appliedRulesOnLine[0] : { from: '', to: '' };
                showNewRuleModal(itemIndex, firstRule.from, firstRule.to);
                return;
            }
            
            if (target.matches('.revert-rule')) {
                const ruleOriginal = target.dataset.ruleOriginal;
                const isChecked = target.checked;
                document.querySelectorAll(`.revert-rule[data-rule-original="${ruleOriginal}"]`).forEach(checkbox => {
                    checkbox.checked = isChecked;
                });
                updateHiddenRules();
                return;
            }

            if (target.matches('.revert-instance')) {
                updateHiddenRules();
                return;
            }

            const interactiveTag = target.closest('.interactive-rule-tag');
            if (interactiveTag) {
                event.preventDefault();
                const from = interactiveTag.dataset.ruleFrom;
                const to = interactiveTag.dataset.ruleTo;
                showRuleManagementModal(from, to);
                return;
            }

            if(target.id === 'show-hidden-summary-link') {
                event.preventDefault();
                showHiddenItemsModal('æ‰€æœ‰è¢«éš±è—çš„é …ç›®', () => true);
                return;
            }
            
            if(target.matches('.show-hidden-rule-link')) {
                event.preventDefault();
                const ruleKey = target.dataset.ruleKey;
                const [from, to] = ruleKey.split(' -> ');
                const title = `è¢«éš±è—çš„è¦å‰‡: <span class="from">${from}</span> â†’ <span class="to">${to}</span>`;
                showHiddenItemsModal(title, (line, rule) => rule.from === from && rule.to === to);
                return;
            }

            const header = target.closest('b');
            if (header && header.textContent.startsWith('ä¿®æ­£å­—å¹•è¡Œ')) {
                event.preventDefault();
                const match = header.textContent.match(/ä¿®æ­£å­—å¹•è¡Œ\((\d+)\)/);
                if (match) {
                    const lineNumberStr = match[1];
                    navigateToSubtitleLine(lineNumberStr);
                }
            }
        });

        function diffStrings(oldStr, newStr) {
            const n = oldStr.length; const m = newStr.length;
            const dp = Array(n + 1).fill(0).map(() => Array(m + 1).fill(0));
            for (let i = 1; i <= n; i++) { for (let j = 1; j <= m; j++) { if (oldStr[i - 1] === newStr[j - 1]) { dp[i][j] = dp[i - 1][j - 1] + 1; } else { dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]); } } }
            let i = n, j = m; let original = '', corrected = '';
            while (i > 0 || j > 0) { if (i > 0 && j > 0 && oldStr[i - 1] === newStr[j - 1]) { original = oldStr[i - 1] + original; corrected = newStr[j - 1] + corrected; i--; j--; } else if (j > 0 && (i === 0 || dp[i][j - 1] >= dp[i - 1][j])) { corrected = `<span class="added">${newStr[j - 1]}</span>` + corrected; j--; } else if (i > 0 && (j === 0 || dp[i][j - 1] < dp[i - 1][j])) { original = `<span class="removed">${oldStr[i - 1]}</span>` + original; i--; } else { break; } }
            return { original, corrected };
        }

        function showAddedRulesModal() {
            addedRulesTextarea.value = newlyAddedRules.value;
            openModal(addedRulesModal); 
        }

        function showRuleManagementModal(from, to) {
            ruleManagementModalList.innerHTML = '';
            let totalCount = 0;
            let appliedCount = 0;
            
            for (const itemIndex in appliedCorrectionsData) {
                const data = appliedCorrectionsData[itemIndex];
                const lineEl = outputLog.querySelector(`.diff-line[data-item-index-line="${itemIndex}"]`);
                if (!lineEl) continue;

                const isRuleApplied = data.rulesApplied.some(rule => rule.from === from && rule.to === to);
                if (isRuleApplied) {
                    totalCount++;
                    if (lineEl.dataset.archived === 'true') continue;
                    
                    const escapedFrom = escapeRegExp(from);
                    const instanceCheckbox = lineEl.querySelector(`.revert-instance[data-item-index="${itemIndex}"][data-rule-original="${escapedFrom}"]`);
                    const globalCheckbox = document.querySelector(`.revert-rule[data-rule-original="${escapedFrom}"]`);
                    
                    const isReverted = (instanceCheckbox && instanceCheckbox.checked) || (globalCheckbox && globalCheckbox.checked);
                    
                    if (!isReverted) {
                        appliedCount++;
                    }
                    
                    const li = document.createElement('li');
                    li.dataset.targetIndex = itemIndex;
                    const originalLineText = data.originalText;
                    const highlightedText = originalLineText.replace(new RegExp(escapedFrom, 'g'), `<span class="removed">${from}</span>`);
                    li.innerHTML = `<label><input type="checkbox" class="modal-revert-cb" data-target-index="${itemIndex}" data-rule-original="${escapedFrom}" ${!isReverted ? 'checked' : ''}><span><a href="#" class="modal-nav-link" data-nav-index="${itemIndex}">è¡Œ ${itemIndex}</a>: ${highlightedText}</span></label>`;
                    ruleManagementModalList.appendChild(li);
                }
            }
            
            const cancelledCount = totalCount - appliedCount;
            ruleManagementModalTitle.innerHTML = `ç®¡ç†è¦å‰‡: <span class="from">${from}</span> â†’ <span class="to">${to}</span> 
                <span class="modal-count-summary">(ç¸½å…±${totalCount}æ¢ / æ‡‰ç”¨é …:${appliedCount} / å–æ¶ˆé …:${cancelledCount})</span>`;
            
            openModal(ruleManagementModal);
        }

        function showHiddenItemsModal(baseTitle, filterFn) {
            const updateTitleWithCount = (listElement, titleElement) => {
                const totalItems = listElement.children.length;
                const checkedItems = listElement.querySelectorAll('input:checked').length;
                const uncheckedItems = totalItems - checkedItems;
                titleElement.innerHTML = `${baseTitle} 
                    <span class="modal-count-summary">(ç¸½å…±${totalItems}é … / æ ¸å–æ¢å¾©é …:${checkedItems} / æœªæ¢å¾©é …:${uncheckedItems})</span>`;
            };

            const existingTab = correctionModal.querySelector('.modal-tab-container');
            if (existingTab) existingTab.remove();

            const tabContainer = document.createElement('div');
            tabContainer.className = 'modal-tab-container';
            tabContainer.innerHTML = `
                <div class="modal-tab active" data-tab-filter="all">ä¸åˆ†é …</div>
                <div class="modal-tab" data-tab-filter="archived">æ­¸æª”é …</div>
                <div class="modal-tab" data-tab-filter="cancelled">å–æ¶ˆé …</div>
            `;
            modalCorrectionList.innerHTML = ''; 
            modalCorrectionList.before(tabContainer);
            
            modalCorrectionList.onchange = () => updateTitleWithCount(modalCorrectionList, modalTitle);

            const allHiddenItems = [];
            document.querySelectorAll('.diff-line').forEach(line => {
                const itemIndex = line.dataset.itemIndexLine;
                const data = appliedCorrectionsData[itemIndex];
                if (!data) return;

                const isLineArchived = line.dataset.archived === 'true';

                data.rulesApplied.forEach(rule => {
                    if (!filterFn(line, rule)) return;

                    const instanceCheckbox = line.querySelector(`.revert-instance[data-item-index="${itemIndex}"][data-rule-original="${escapeRegExp(rule.from)}"]`);
                    const globalCheckbox = document.querySelector(`.revert-rule[data-rule-original="${escapeRegExp(rule.from)}"]`);
                    
                    const isInstanceCancelled = instanceCheckbox ? instanceCheckbox.checked : false;
                    const isGloballyCancelled = globalCheckbox ? globalCheckbox.checked : false;

                    if (isLineArchived) {
                        allHiddenItems.push({ data, itemIndex, type: 'archived', rule: rule });
                    } else if (isInstanceCancelled || isGloballyCancelled) {
                         allHiddenItems.push({ data, itemIndex, type: 'cancelled', rule: rule });
                    }
                });
            });

            const renderList = (filterType) => {
                modalCorrectionList.innerHTML = '';
                const itemsToRender = allHiddenItems.filter(item => filterType === 'all' || item.type === filterType);
                
                itemsToRender.forEach(({ data, itemIndex, type, rule }) => {
                    const reason = type === 'archived' ? 'å·²æ­¸æª”' : 'å·²å–æ¶ˆ';
                    const reasonClass = type === 'archived' ? 'reason-archived' : 'reason-cancelled';
                    const action = type === 'archived' ? 'unarchive' : 'unrevert';
                    
                    const highlightedText = data.originalText.replace(new RegExp(escapeRegExp(rule.from), 'g'), `<span class="removed">${rule.from}</span>`);
                    const li = document.createElement('li');
                    li.innerHTML = `<label>
                        <input type="checkbox" class="modal-unhide-cb" 
                               data-target-line-index="${itemIndex}" 
                               data-rule-original="${escapeRegExp(rule.from)}" 
                               data-action="${action}">
                        <span>
                            <a href="#" class="modal-nav-link" data-nav-index="${itemIndex}">è¡Œ ${itemIndex}</a>: 
                            ${highlightedText} 
                            (å¥—ç”¨è¦å‰‡: <a href="#" class="modal-rule-link" data-rule-from="${rule.from}" data-rule-to="${rule.to}">${rule.from}â†’${rule.to}</a>)
                            <span class="hide-reason ${reasonClass}">(${reason})</span>
                        </span>
                    </label>`;
                    modalCorrectionList.appendChild(li);
                });
                updateTitleWithCount(modalCorrectionList, modalTitle);
            };

            tabContainer.addEventListener('click', (e) => {
                if (e.target.classList.contains('modal-tab')) {
                    tabContainer.querySelector('.active').classList.remove('active');
                    e.target.classList.add('active');
                    renderList(e.target.dataset.tabFilter);
                }
            });

            renderList('all');
            modalApplyBtn.dataset.modalType = 'unhide-items';
            openModal(correctionModal);
        }

        modalCloseBtn.addEventListener('click', () => closeModal(correctionModal));
        modalSelectAll.addEventListener('click', () => { 
            modalCorrectionList.querySelectorAll('input[type="checkbox"]').forEach(cb => cb.checked = true);
            if(modalTitle.textContent.includes('æ‰€æœ‰è¢«éš±è—çš„é …ç›®')) modalCorrectionList.onchange();
        });
        modalDeselectAll.addEventListener('click', () => { 
            modalCorrectionList.querySelectorAll('input[type="checkbox"]').forEach(cb => cb.checked = false); 
            if(modalTitle.textContent.includes('æ‰€æœ‰è¢«éš±è—çš„é …ç›®')) modalCorrectionList.onchange();
        });
        
        modalCorrectionList.addEventListener('click', (event) => {
            const navLink = event.target.closest('a.modal-nav-link');
            const ruleLink = event.target.closest('a.modal-rule-link');
            if (navLink) { event.preventDefault(); event.stopPropagation(); const lineNumber = navLink.dataset.navIndex; if (lineNumber) navigateToSubtitleLine(lineNumber); return; }
            if (ruleLink) { event.preventDefault(); event.stopPropagation(); const from = ruleLink.dataset.ruleFrom; const to = ruleLink.dataset.ruleTo; if(from && to) showRuleManagementModal(from, to); return; }
        });

        modalApplyBtn.addEventListener('click', () => {
            const modalType = modalApplyBtn.dataset.modalType;
            if (modalType === 'unhide-items') {
                modalCorrectionList.querySelectorAll('.modal-unhide-cb:checked').forEach(modalCb => {
                    const itemIndex = modalCb.dataset.targetLineIndex;
                    const action = modalCb.dataset.action;
                    const ruleOriginal = modalCb.dataset.ruleOriginal;
                    const line = outputLog.querySelector(`.diff-line[data-item-index-line="${itemIndex}"]`);
                    if (line) {
                        if (action === 'unarchive') { 
                            line.dataset.archived = 'false';
                        } else if (action === 'unrevert') {
                            const instanceCb = line.querySelector(`.revert-instance[data-rule-original="${ruleOriginal}"]`);
                            const globalCb = document.querySelector(`.revert-rule[data-rule-original="${ruleOriginal}"]`);
                            if (instanceCb) instanceCb.checked = false;
                            if (globalCb) globalCb.checked = false;
                        }
                    }
                });
                 alert('å·²æ¢å¾©æ‰€é¸é …ç›®çš„é¡¯ç¤ºã€‚');
            }
            updateHiddenRules();
            closeModal(correctionModal);
        });

        ruleManagementCloseBtn.addEventListener('click', () => closeModal(ruleManagementModal));
        ruleManagementSelectAll.addEventListener('click', () => { ruleManagementModalList.querySelectorAll('input[type="checkbox"]').forEach(cb => cb.checked = true); });
        ruleManagementDeselectAll.addEventListener('click', () => { ruleManagementModalList.querySelectorAll('input[type="checkbox"]').forEach(cb => cb.checked = false); });
        ruleManagementModalList.addEventListener('click', (event) => {
             const navLink = event.target.closest('a.modal-nav-link');
             if (navLink) { event.preventDefault(); event.stopPropagation(); const lineNumber = navLink.dataset.navIndex; if (lineNumber) navigateToSubtitleLine(lineNumber); }
        });
        ruleManagementArchiveBtn.addEventListener('click', () => {
            const itemsToArchive = [];
            ruleManagementModalList.querySelectorAll('.modal-revert-cb:checked').forEach(cb => {
                const itemIndex = cb.dataset.targetIndex;
                const line = outputLog.querySelector(`.diff-line[data-item-index-line="${itemIndex}"]`);
                if (line) { line.dataset.archived = 'true'; itemsToArchive.push(cb.closest('li')); }
            });
            if (itemsToArchive.length === 0) { alert("è«‹å…ˆå‹¾é¸è¦æ­¸æª”çš„é …ç›®ã€‚"); return; }
            itemsToArchive.forEach(li => li.remove());
            alert(`${itemsToArchive.length} å€‹é …ç›®å·²æ­¸æª”ä¸¦å¾åˆ—è¡¨ä¸­ç§»é™¤ã€‚`);
            updateHiddenRules();
            if (ruleManagementModalList.querySelectorAll('li').length === 0) { closeModal(ruleManagementModal); }
        });
        ruleManagementApplyBtn.addEventListener('click', () => {
            ruleManagementModalList.querySelectorAll('.modal-revert-cb').forEach(modalCb => {
                const itemIndex = modalCb.dataset.targetIndex;
                const ruleOriginal = modalCb.dataset.ruleOriginal;
                const mainInstanceCheckbox = document.querySelector(`.revert-instance[data-item-index="${itemIndex}"][data-rule-original="${ruleOriginal}"]`);
                if (mainInstanceCheckbox) { 
                    mainInstanceCheckbox.checked = !modalCb.checked; 
                }
            });
            alert('é¸æ“‡å·²æ›´æ–°ã€‚æœ€çµ‚çµæœå°‡åœ¨ä¸‹è¼‰æ™‚ç”Ÿæ•ˆã€‚');
            updateHiddenRules();
            closeModal(ruleManagementModal);
        });

        addedRulesSaveChangesBtn.addEventListener('click', () => {
            newlyAddedRules.value = addedRulesTextarea.value;
            alert('å·²å„²å­˜æ‰‹å‹•æ–°å¢çš„è¦å‰‡ï¼');
            closeModal(addedRulesModal);
        });
        addedRulesCloseBtn.addEventListener('click', () => closeModal(addedRulesModal));
        listAddedRulesBtn.addEventListener('click', () => showAddedRulesModal());
        newRuleCloseBtn.addEventListener('click', () => closeModal(newRuleModal));

        newRuleConfirmBtn.addEventListener('click', () => {
            const original = document.getElementById('modal-rule-original').value.trim();
            const replacement = document.getElementById('modal-rule-replacement').value.trim();
            const exclusion = document.getElementById('modal-rule-exclusion').value.trim();
            const lines = document.getElementById('modal-rule-lines').value.trim();

            if (!original) {
                alert('ã€ŒåŸå§‹å­—å¹•ã€æ¬„ä½ä¸å¯ç‚ºç©ºï¼');
                return;
            }
            let ruleString = `-<${original}[${replacement}]`;
            if (exclusion || lines) {
                ruleString += `|${exclusion}|${lines}`;
            }
            ruleString += '>';

            newlyAddedRules.value += (newlyAddedRules.value ? '\n' : '') + ruleString;
            alert(`å·²æ–°å¢è¦å‰‡:\n${ruleString}\n\næ‚¨å¯ä»¥åœ¨ä¸‹è¼‰æ™‚å¥—ç”¨æ­¤æ–°è¦å‰‡ã€‚`);
            closeModal(newRuleModal);
        });

        settingsBtn.addEventListener('click', (e) => {
            e.preventDefault();
            openModal(settingsModal);
        });
        settingsCloseBtn.addEventListener('click', () => closeModal(settingsModal));

        windowStackingToggle.addEventListener('change', saveSettings);
        defaultShowRevertToggle.addEventListener('change', saveSettings);

        function startFollow() {
            if (!followVideoToggle.checked || !currentPlayer.isReady) { return; }
            stopFollow(); 
            followInterval = setInterval(updateFollow, 500);
        }

        function stopFollow() {
            clearInterval(followInterval);
            followInterval = null;
            lastActiveLineIndex = -1;
        }
        
        function updateFollow() {
            if (!currentPlayer.player || currentParsedSubs.length === 0) return;

            let currentTime = 0;
            if (currentPlayer.type === 'youtube' && typeof currentPlayer.player.getCurrentTime === 'function') {
                currentTime = currentPlayer.player.getCurrentTime();
            } else if (currentPlayer.type === 'local') {
                currentTime = currentPlayer.player.currentTime;
            }
            const currentTimeMs = currentTime * 1000;
            
            const activeSubIndex = currentParsedSubs.findIndex(sub => {
                const startMs = timeToMs(sub.originalFormat === 'formatSrt' ? sub.start : vttLikeTimeToSrt(sub.start));
                const endMs = timeToMs(sub.originalFormat === 'formatSrt' ? sub.end : vttLikeTimeToSrt(sub.end));
                return currentTimeMs >= startMs && currentTimeMs <= endMs;
            });
            
            if (activeSubIndex !== -1 && activeSubIndex !== lastActiveLineIndex) {
                lastActiveLineIndex = activeSubIndex;
                const activeSub = currentParsedSubs[activeSubIndex];
                highlightAndScrollToLine(activeSub.index);
            }
        }

        followVideoToggle.addEventListener('change', () => {
            if (followVideoToggle.checked) { startFollow(); } else { stopFollow(); }
        });

        loadSettings(); 
        handleSubtitleTextChange();
        toggleCorrectionButtons();
        loadVideoBtn.addEventListener('click', loadVideo);
        localVideoFile.addEventListener('change', loadLocalVideo);
    });
    </script>
</body>
</html>